<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Omar Huseynov">

    <title>The Fall of the House of Vulkan</title>

    <!-- favicon -->
    <link rel="icon" type="image/png" href="../favico/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../favico/favicon.svg" />
    <link rel="shortcut icon" href="../favico/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../favico/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="E954" />
    <link rel="manifest" href="../favico/site.webmanifest" />

    <!-- code highlighting stuff -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/vs.min.css" integrity="sha512-AVoZ71dJLtHRlsgWwujPT1hk2zxtFWsPlpTPCc/1g0WgpbmlzkqlDFduAvnOV4JJWKUquPc1ZyMc5eq4fRnKOQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/highlight.min.js" integrity="sha512-6yoqbrcLAHDWAdQmiRlHG4+m0g/CT/V9AGyxabG8j7Jk8j3r3K6due7oqpiRMZqcYe9WM2gPcaNNxnl2ux+3tA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/c.min.js" integrity="sha512-Ny9z3+WJkmC2xW098BNYhPajzsf8iBika/+58Mh4lHCF/it92UR32xhytP4I/yxKmF1fkcEgIF87qbGyz1nmDQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>hljs.highlightAll();</script>
    
    <link rel="stylesheet" href="../css/blog.css">

    <!-- Cloudflare Web Analytics -->
    <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "c4b2320f0ee04848bb6f51954d84c0d8"}'></script>
    <!-- End Cloudflare Web Analytics -->
</head>
<body>
    <span class="home-btn"><a href="/">Go back to home page</a></span>

    <!-- TITLE -->
    <h1>The Fall of the House of Vulkan</h1>
    <h2 id="prologue">Prologue</h2>

    <!-- INTRODUCTION -->
    <article>
    <p>
        <i>
            During the whole of a dull, dark, and soundless day in the autumn of the year, when the clouds hung oppressively low in the heavens,
            I had been programming alone, on a laptop, a singularly dreary project; and at length found myself, as the shades of the evening
            drew on, within view of the interpolated triangle. I know not how it was, but, with the first glimpse of the API,
            a sense of insufferable doom pervaded my spirit.
        </i>
    </p>
    <p>
        Take a look at this image:
    </p>
    <p>
        <a href="https://en.wikipedia.org/wiki/Utah_teapot#/media/File:Utah_teapot_simple_2.png" target="_blank"><img alt="3D render of the Utah teapot" src="https://upload.wikimedia.org/wikipedia/commons/5/5f/Utah_teapot_simple_2.png"></a>
    </p>
    <p>
        What is it?
    </p>
    <p>
        Well, it's a teapot.
    </p>
    <p>
        Is it <em>real</em>?
    </p>
    <p>
        Of course not.
    </p>
    <p>
        This teapot was <em>inspired</em> by a <a href="https://en.wikipedia.org/wiki/Utah_teapot#/media/File:Original_Utah_Teapot.jpg" target="_blank">real teapot</a>,
        but, alas, the image above is <em>not</em> the image of a real teapot.
        It's an imitation, an artificial reproduction, a simulacrum, and a convincing one at that.
    </p>
    <p>
        Does it matter that it is <em>not</em> real? What is the difference between the real and the fake?
    </p>
    <p>
        I'm not here to discuss <a href="https://a.co/d/5n0AdIY" target="_blank">philosophy</a>.
    </p>
    <p>
        No, I'm here to tell you something more important:
    </p>
    <p>
        You have been scammed.
    </p>
    <p>
        A trillion-dollar industry has convinced you that you need to pay <a href="https://www.amazon.com/s?k=rtx+4090" target="_blank">thousands of dollars</a> to create your own simulacra.
    </p>
    <p>
        And that you also need to write a <a href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/triangle/triangle.cpp" target="_blank">thousand lines</a> of code just to see a single triangle.
    </p>
    <p>
        I am here to tell you that there's another way. That you can do all that by yourself.
    </p>
    <p>
        I know you already think of me as a hero, and I accept this responsibility.
    </p>
    <p>
        So bring up your terminal, open your favorite text editor, and let's make our own simulator.
        You may use an <a href="https://www.learncpp.com/cpp-tutorial/installing-an-integrated-development-environment-ide/" target="_blank">IDE</a> if you wish.
        I am not here to teach you all the technicalities involved
        in compiling and linking the source code, you will have to learn that <a href="https://www.learncpp.com/cpp-tutorial/compiling-your-first-program/" target="_blank">somewhere else</a>.
        Nor will I teach you how to program in <a href="https://a.co/d/8qRAAeX" target="_blank">C</a>.
        But I <em>will</em> teach you the computer science behind generating images like the teapot above.
        No GPUs or <a href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html" target="_blank">convoluted APIs</a> are needed. There is a great joy in writing your own computer graphics code from scratch,
        and my hope is to deliver that joy to <em>you</em>.
    </p>
    </article>

    <!-- FIRST PRINCIPLES -->
    <h2 id="first-principles">First Principles</h2>
    <article>
    <p>
        What is the first step in creating our own <a href="https://en.wikipedia.org/wiki/The_Matrix" target="_blank">matrix</a>?
        We don't just want to build a general-purpose simulation, we want to <em>experience it</em>, too.
        That means we need some sort of a portal into another dimension -
        a <a href="https://narnia.fandom.com/wiki/Wardrobe" target="_blank">wardrobe</a> that opens to Narnia.
        There are different ways of accomplishing this. One of them is by creating an image, and then displaying it on an image viewer.
        But there are <a href="https://en.wikipedia.org/wiki/Image_file_format#Major_graphic_file_formats" target="_blank">so many</a> image formats, which one to choose?
    </p>
    <p>
        One of the simplest image formats is <a href="https://en.wikipedia.org/wiki/Netpbm" target="_blank">PPM</a>.
        Here's an example from wikipedia:
        <table>
            <tr>
                <td>P3</td>
            </tr>
            <tr>
                <td>3</td>
                <td>2</td>
            </tr>
            <tr>
                <td>255</td>
            </tr>
            <tr>
                <td>255</td>
                <td>0</td>
                <td>0</td>
            </tr>
            <tr>
                <td>0</td>
                <td>255</td>
                <td>0</td>
            </tr>
            <tr>
                <td>0</td>
                <td>0</td>
                <td>255</td>
            </tr>
            <tr>
                <td>255</td>
                <td>255</td>
                <td>0</td>
            </tr>
            <tr>
                <td>255</td>
                <td>255</td>
                <td>255</td>
            </tr>
            <tr>
                <td>0</td>
                <td>0</td>
                <td>0</td>
            </tr>
        </table>
    </p>
    <p>
        <strong>P3</strong> denotes that this is an <a href="https://en.wikipedia.org/wiki/ASCII" target="_blank">ASCII</a> file.
        <strong>3</strong> and <strong>2</strong> are the width and the height of the image, respectively.
        <strong>255</strong> on the next line means <em>"end of header"</em>. That is, everything that comes after this line are the actual colors of the image,
        which we discuss next.
    </p>
    <p>
        What <i>is</i> <strong>color</strong>? This may shock you when I say this, but, colors aren't <em>real</em>. They don't actually exist.
        Colors are no more real than the Santa Claus who gifts you presents (or coal!) every Christmas.
        We all partake in a great conspiracy when we open our eyes and <em>see</em>. Colors form an important part of our shared hallucination of the world,
        alongside money and religion. It's funny when you think about it: the teapot that you saw earlier is a lie that approximates another lie
        concocted by the buzzing of neurons inside your <a href="https://en.wikipedia.org/wiki/Visual_cortex" target="_blank">visual cortex</a>.
    </p>
    <p>
        In the real world we have something called <a href="https://en.wikipedia.org/wiki/Electromagnetic_spectrum" target="_blank">the electromagnetic spectrum</a>,
        only a small part of which makes up the wavelengths that the human eye can see:
    </p>
    <p>
        <img alt="Electromagnetic spectrum" src="../img/spectrum.svg">
    </p>
    <p>
        Worse, the cells within your eye have different sensitivities to different parts of the visible spectrum.
        The image below (which I yoinked from <a href="https://www.simplypsychology.org/what-is-the-trichromatic-theory-of-color-vision.html" target="_blank">simplepsychology.org</a>)
        illustrates this nicely: 
    </p>
    <p>
        <img alt="Human color sensitivities" src="../img/eye-color-sensitivity.webp">
    </p>
    <p>
        The human eye is more sensitive to some colors than others.
        You may see some colors <em>"brighter"</em> than others (assuming that you're a human reading this page).
        Also, due to the awkward wiring of the optical nerve, you have been gifted a blind spot:
    </p>
    <p>
        <img alt="Human eye blind spot" src="../img/blind-spot.jpg">
    </p>
    <p>
        <i>"But... I don't see any dark patches in my vision?!"</i>, you might say.
        Well, thanks to this oopsie made by the clunky hand of evolution,
        your brain now has to compensate for this by literally <a href="https://en.wikipedia.org/wiki/Blind_spot_(vision)" target="_blank">filling in</a> the void.
        Life decided that it would rather hallucinate than to actually see.
    </p>
    <p>
        You live your life in your very own <a href="https://en.wikipedia.org/wiki/Metaverse" target="_blank">Metaverse</a>,
        powered by the three pounds of flesh in your skull.
    </p>
    <p>
        By the way, cephalopods <a href="https://youtu.be/HATW8xJMxAc?si=E_YykDNmXw-hIPkN" target="_blank">don't have this problem</a>.
    </p>
    <p>
        What I want you to get from all this is that everything that you see is fake: you are fake, I am fake, your Mom is fake...
    </p>
    <p>
        As long as our delusions don't harm the reproductive success of our species, they will persist,
        and we seem to be the only species who use technology to indulge ourselves in artificial delusions.
        We went from <a href="https://en.wikipedia.org/wiki/Lascaux" target="_blank">cave paintings</a> to <a href="https://youtu.be/dYk7byKHSRw?feature=shared" target="_blank">this</a>
        in the blink of an eye (in cosmological timescales).
        There is clearly great value in running simulations, especially those that we get to <em>experience</em>.
        There are philosophers who think the simulation is <a href="https://simulation-argument.com/" target="_blank">the final technology</a>.
    </p>
    <p>
        That being said, the chicanery of light and color is often too complex for computers to handle
        (especially when we want to generate images <em>fast</em>).
        Instead what we do is take the visible part of the electromagnetic spectrum and quantize it based on the intensity of three colors:
        <span style="color: red;">RED</span>, <span style="color: green;">GREEN</span>, and <span style="color: blue;">BLUE</span>,
        to the much chagrin of <a href="https://en.wikipedia.org/wiki/Tetrachromacy" target="_blank">tetrachromats</a>.
        We represent each of these intensities as an 8-bit unsigned integer between 0 and 255.
        This gives us a total of 256 * 256 * 256 = 16777216 (~16 million) colors to work with. Not bad.
    </p>
    <p>
        Take a look at that PPM image again. The first row is:
    </p>
    <p>
        <table>
            <tr>
                <td>255</td>
                <td>0</td>
                <td>0</td>
            </tr>
        </table>
    </p>
    <p>
        This array of numbers represents the <span style="color: red;">RED</span> color.
        The next row is:
    </p>
    <p>
        <table>
            <tr>
                <td>0</td>
                <td>255</td>
                <td>0</td>
            </tr>
        </table>
    </p>
    <p>
        This is the <span style="color: green;">GREEN</span> color.
        When we <em>interpret</em> the color information together with the width and the height of the image, we get the following picture:
    </p>
    <p>
        <img alt="PPM image example" src="../img/ppm.svg">
    </p>
    <p>
        We now know that to generate images we will need a structure that stores width, height, and an array of numbers that represents the colors.
        So, let us do that:
    </p>
    <pre><code class="mono">#include &ltstdio.h&gt
#include &ltstdint.h&gt
#include &ltstdlib.h&gt
#include &ltassert.h&gt

typedef struct
{
    uint8_t x;
    uint8_t y;
    uint8_t z;
    uint8_t w;
}
CgVec4U8;

typedef struct
{
    uint32_t width;
    uint32_t height;
    uint32_t* pixels;
}
CgColorBufferU32;

CgColorBufferU32 cgCreateColorBufferU32(uint32_t width,
                                        uint32_t height)
{
    assert(width &gt 0 && height &gt 0 && "cgCreateColorBufferU32: width or height is zero");

    CgColorBufferU32 colorBuffer = {};
    colorBuffer.width = width;
    colorBuffer.height = height;
    colorBuffer.pixels = malloc(width * height * sizeof(uint32_t));
    if (!colorBuffer.pixels) {
        perror("cgCreateColorBufferU32");
        exit(EXIT_FAILURE);
    }
    return colorBuffer;
}

void cgClearColorBufferU32(CgColorBufferU32* restrict colorBuffer,
                           CgVec4U8 color)
{
    assert(colorBuffer && "cgClearColorBufferU32: colorBuffer is NULL");

    uint32_t pixel = ((uint32_t)color.x) |
                     ((uint32_t)color.y &lt&lt 8) |
                     ((uint32_t)color.z &lt&lt 16) |
                     ((uint32_t)color.w &lt&lt 24);

    uint32_t resolution = colorBuffer-&gtwidth * colorBuffer-&gtheight;
    for (uint32_t i = 0; i &lt resolution; ++i) {
        colorBuffer-&gtpixels[i] = pixel;
    }
}

void cgColorBufferU32ToPPM(const CgColorBufferU32* restrict colorBuffer,
                           const char* restrict path)
{
    assert(colorBuffer && "cgColorBufferU32ToPPM: colorBuffer is NULL");
    assert(path && "cgColorBufferU32ToPPM: path is NULL");

    FILE* fp = fopen(path, "w");
    if (!fp) {
        perror("cgColorBufferU32ToPPM");
        exit(EXIT_FAILURE);
    }
    fprintf(fp, "P3\n");
    fprintf(fp, "%u %u\n", colorBuffer-&gtwidth, colorBuffer-&gtheight);
    fprintf(fp, "255\n");
    uint32_t resolution = colorBuffer-&gtwidth * colorBuffer-&gtheight;
    for (uint32_t i = 0; i &lt resolution; ++i) {
        uint32_t pixel = colorBuffer-&gtpixels[i];
        uint8_t red = *((uint8_t*)&pixel + 0);
        uint8_t green = *((uint8_t*)&pixel + 1);
        uint8_t blue = *((uint8_t*)&pixel + 2);
        fprintf(fp, "%u %u %u\n", red, green, blue);
    }
    fclose(fp);
}

int main()
{
    uint32_t width = 320;
    uint32_t height = 240;
    CgVec4U8 clearColor = { 255, 150, 255, 255 };
    CgColorBufferU32 colorBuffer = cgCreateColorBufferU32(width, height);
    cgClearColorBufferU32(&colorBuffer, clearColor);
    cgColorBufferU32ToPPM(&colorBuffer, "sample.ppm");
    return 0;
}</code></pre>
    <p>
        Running the code above creates the image below:
    </p>
    <p>
        <img alt="Output of the code" src="../img/cursedgl_0.png">
    </p>
    <p>
        I converted the PPM to <a href="https://en.wikipedia.org/wiki/PNG" target="_blank">PNG</a> since web browsers can't render PPM images
        (maybe some can, but <a href="https://www.mozilla.org/en-US/firefox/" target="_blank">firefox</a> couldn't).
    </p>
    <p>
        There is a long way to go before our image starts to look like a teapot. But we already have the fundamental structures:
    </p>
    <pre><code class="mono">typedef struct
{
    uint8_t x;
    uint8_t y;
    uint8_t z;
    uint8_t w;
}
CgVec4U8;</code></pre>
    <p>
        Since C doesn't have namespaces, I name my structures with a two-letter identifier <strong>Cg</strong> to prevent naming conflicts.
        Here, <strong>Cg</strong> stands for "Computer graphics", but you may use your own naming scheme if you wish.
        Next, <strong>Vec4</strong> stands for the 4-dimensional vector
        (if you need some refreshing on vectors, <a href="https://www.realtimerendering.com/" target="_blank">realtimerendering.com</a>
        has a nice <a href="https://www.realtimerendering.com/Real-Time_Rendering_4th-Appendices.pdf" target="_blank">PDF</a> that you can read).
        Finally, I indicate the type of the elements in the structure: <strong>U8</strong>, which stands for 8-bit unsigned integer.
    </p>
    <p>
        Therefore, a 4D floating-point vector can be defined as <strong>CgVec4F32</strong>:
    </p>
    <pre><code class="mono">typedef struct
{
    float x;
    float y;
    float z;
    float w;
}
CgVec4F32;</code></pre>
    <p>
        The struct <strong>CgColorBufferU32</strong> follows the same convention.
        After all, we need a place to <em>store</em> the image, so we will use the <strong>pixels</strong> pointer
        to refer to some place in memory where the image is stored:
    </p>
    <pre><code class="mono">typedef struct
{
    uint32_t width;
    uint32_t height;
    uint32_t* pixels;
}
CgColorBufferU32;</code></pre>
    <p>
        Each pixel is defined as an unsigned 32-bit integer (8-bit per channel, with an alpha value that we will discuss later).
    </p>
    <p>
        Then we define the <strong>cgCreateColorBufferU32</strong> function that allocates a new buffer to store the image.
        Note that the <strong>cgCreateColorBufferU32</strong> doesn't <em>initialize</em> the buffer,
        it only <em>allocates</em> enough memory to <em>store</em> the image.
        This goes against the <strong>"never forget initializing your variables"</strong> mantra, but
        the values of the color buffer are likely to be discarded and/or written to anyway,
        so it doesn't really make sense to initialize it with default color values.
        Instead we have another function that updates the color buffer given a single color:
        <strong>cgClearColorBufferU32</strong>. Note how the 32-bit pixels are generated:
    </p>
    <pre><code class="mono">uint32_t pixel = ((uint32_t)color.x) |
                 ((uint32_t)color.y &lt&lt 8) |
                 ((uint32_t)color.z &lt&lt 16) |
                 ((uint32_t)color.w &lt&lt 24);</code></pre>
    <p>
        Here the <strong>x</strong>, <strong>y</strong>, <strong>z</strong>, <strong>w</strong>
        values correspond to the <span style="color: red;">red</span>, <span style="color: green;">green</span>,
        <span style="color: blue;">blue</span>, and <span>alpha</span> values.
        What is <em>alpha</em>? Roughly speaking, the alpha represents the transparency of the image.
        That is to say, if there was <em>another</em> image behind <em>our</em> image, then the alpha values
        of our image would determine <em>the extent to which</em> the colors of the background image would <em>bleed through</em> our image.
        This description is a little abstract, but don't worry, we will look at transparency in more detail later.
    </p>
    <p>
        Each <strong>uint32_t pixel</strong> stores the red value in its least significant 8 bits
        (assuming that we are programming in a <a href="https://en.wikipedia.org/wiki/Endianness" target="_blank">little-endian</a> machine).
        Why? For no particular reason. Different applications may use different pixel layouts, and switching between layouts is trivial.
        But once the layout is determined, we have to be consistent, and we are: our function <strong>cgColorBufferU32ToPPM</strong>
        assumes the red will be found in the least significant 8 bits of the given <strong>uint32_t</strong> value:
    </p>
    <pre><code class="mono">uint32_t pixel = colorBuffer-&gtpixels[i];
uint8_t red = *((uint8_t*)&pixel + 0);
uint8_t green = *((uint8_t*)&pixel + 1);
uint8_t blue = *((uint8_t*)&pixel + 2);
fprintf(fp, "%u %u %u\n", red, green, blue);</code></pre>
    <p>
        An image with a single color is kind of boring though. We can write another function <strong>cgGradientColorBufferU32</strong>
        that draws a gradient across the image:
    </p>
    <pre><code class="mono">void cgGradientColorBufferU32(CgColorBufferU32* restrict colorBuffer,
                              CgVec4U8 topLeftColor,
                              CgVec4U8 topRightColor,
                              CgVec4U8 bottomLeftColor,
                              CgVec4U8 bottomRightColor)
{
    assert(colorBuffer && "cgGradientColorBufferU32: colorBuffer is NULL");

    CgVec4F32 topLeftColorF32 = cgConvertVec4U8ToF32(topLeftColor);
    CgVec4F32 topRightColorF32 = cgConvertVec4U8ToF32(topRightColor);
    CgVec4F32 bottomLeftColorF32 = cgConvertVec4U8ToF32(bottomLeftColor);
    CgVec4F32 bottomRightColorF32 = cgConvertVec4U8ToF32(bottomRightColor);

    for (uint32_t i = 0; i &lt colorBuffer->width; ++i) {
        float x = (float)i / (float)colorBuffer->width;
        for (uint32_t j = 0; j &lt colorBuffer->height; ++j) {
            float y = (float)j / (float)colorBuffer->height;

            CgVec4F32 topColor = cgLerpVec4F32(topLeftColorF32, topRightColorF32, x);
            CgVec4F32 bottomColor = cgLerpVec4F32(bottomLeftColorF32, bottomRightColorF32, x);
            CgVec4F32 finalColor = cgLerpVec4F32(topColor, bottomColor, y);

            CgVec4U8 color = cgConvertVec4F32ToU8(finalColor);
            uint32_t pixel = cgConvertVec4U8ToU32(color);
            colorBuffer->pixels[j * colorBuffer->width + i] = pixel;
        }
    }
}</code></pre>
    <p>
        We can create gradients by <em>linearly interpolating</em> between the given color values.
        To understand linear interpolation better let us interpolate between two real values, say <strong>a</strong>
        and <strong>b</strong>. We can define <strong>k</strong> as another real value,
        between 0.0 and 1.0, that denotes the <em>amount</em> of interpolation to do.
        You can think of <strong>k</strong> as the <em>distance</em> to travel from
        <strong>a</strong> to <strong>b</strong>.
        When <strong>k</strong> equals 0, we don't travel at all, so we return <strong>a</strong>.
        When <strong>k</strong> equals 1, then we travel the full distance, and thus we return <strong>b</strong>.
        If <strong>k</strong> equals 0.5, then we travel half the distance, so return the half of <strong>a</strong>
        plus the half of <strong>b</strong>.
    </p>
    <p>
        In our case we are trying to interpolate across a two-dimensional surface (our image), so we have two <strong>k</strong>s.
        We can calculate these <strong>k</strong>s by dividing the position of the current pixel
        (<strong>i</strong> and <strong>j</strong>) by the width and the height of our image.
        This works because <strong>i</strong> will always be between 0 and the width of the image,
        so dividing <strong>i</strong> by the width will always yield a value between 0.0 and 1.0
        (technically speaking, we will never reach 1.0, since <strong>i</strong> will never be the width of the image, but this is okay, because it will get
        very close to 1.0 anyway. If you're bothered by this, you can instead divide by (width - 1), which <em>will</em> produce the correct interpolation).
        The same remark applies to <strong>j</strong>: diving <strong>j</strong> by the height of the image will also produce a value between 0.0 and 1.0.
    </p>
    <p>
        Now we can use these <strong>k</strong>s to linearly interpolate between the given color values.
        Because <strong>k</strong>s are floating-point values, it's best that we convert our colors to their
        floating-point equivalents as well, lest we litter the codebase with <a href="https://stackoverflow.com/questions/7558837/what-exactly-is-a-type-cast-in-c-c" target="_blank">type casts</a>.
        Instead we bury the casts in functions, e.g. with <strong>cgConvertVec4U8ToF32</strong>:
    </p>
    <pre><code class="mono">CgVec4F32 cgConvertVec4U8ToF32(CgVec4U8 v)
{
    CgVec4F32 r = { .x = (float)v.x,
                    .y = (float)v.y,
                    .z = (float)v.z,
                    .w = (float)v.w };
    return r;
}</code></pre>
    <p>
        The linear interpolation is computed by the <strong>cgLerpVec4F32</strong> function:
    </p>
    <pre><code class="mono">CgVec4F32 cgLerpVec4F32(CgVec4F32 p,
                        CgVec4F32 q,
                        float k)
{
    CgVec4F32 r = {
        .x = (1.0f - k) * p.x + k * q.x,
        .y = (1.0f - k) * p.y + k * q.y,
        .z = (1.0f - k) * p.z + k * q.z,
        .w = (1.0f - k) * p.w + k * q.w
    };
    return r;
}</code></pre>
    <p>
        Notice how when <strong>k</strong> equals 0, we return the first value (<strong>p</strong>),
        and when it equals 1, we return the second value (<strong>q</strong>), and for the remaining values of
        <strong>k</strong> it is a mixture of both.
        Once interpolated, we convert the <strong>CgVec4F32</strong> back to <strong>CgVec4U8</strong>
        using <strong>cgConvertVec4F32ToU8</strong>:
    </p>
    <pre><code class="mono">CgVec4U8 cgConvertVec4F32ToU8(CgVec4F32 v)
{
    CgVec4U8 r = { .x = (uint8_t)v.x,
                   .y = (uint8_t)v.y,
                   .z = (uint8_t)v.z,
                   .w = (uint8_t)v.w };
    return r;
}</code></pre>
    <p>
        But since we store pixels as <strong>uint32_t</strong> values, we need to convert our <strong>CgVec4U8</strong>
        to a 32-bit unsigned integer via <strong>cgConvertVec4U8ToU32</strong>:
    </p>
    <pre><code class="mono">uint32_t cgConvertVec4U8ToU32(CgVec4U8 color)
{
    uint32_t pixel = ((uint32_t)color.x) |
                     ((uint32_t)color.y &lt&lt 8) |
                     ((uint32_t)color.z &lt&lt 16) |
                     ((uint32_t)color.w &lt&lt 24);
    return pixel;
}</code></pre>
    <p>
        If we use <span style="color: red;">RED</span> for the top-left color,
        <span style="color: green;">GREEN</span> for the top-right color,
        <span style="color: blue;">BLUE</span> for the bottom-left color, and
        <span style="color: yellow;">YELLOW</span> for the bottom-right color, then <strong>cgGradientColorBufferU32</strong> will produce the following image:
    </p>
    <p>
        <img alt="Output of the code" src="../img/cursedgl_1.png">
    </p>
    <p>
        You need to understand interpolation <em>well</em>, because we will use it again, albeit for a different geometry.
    </p>
    </article>

    <!-- FLOATING-POINT BUFFERS -->
    <h2 id="floating-point-buffers" class="chapter merriweather-black">Floating-point Buffers</h2>
    <article>
    <p>
        So far we have been storing our color values in <strong>CgColorBufferU32</strong>,
        and while there isn't anything inherently wrong with 8-bit colors, it is often much easier to work
        with floating-point values. We have already seen this in the <strong>cgGradientColorBufferU32</strong>
        function. Linear interpolation works best with floating-point values as the <em>amount to interpolate</em> between two values
        is given by a real number between 0.0 and 1.0. In our case we could have simply defined a <strong>uint8_t</strong>
        variant of the 
    </p>
    </article>
</body>
</html>
