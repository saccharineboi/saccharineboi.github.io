<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Omar Huseynov">

    <title>The Fall of the House of Vulkan</title>

    <!-- favicon -->
    <link rel="icon" type="image/png" href="../favico/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../favico/favicon.svg" />
    <link rel="shortcut icon" href="../favico/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../favico/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="E954" />
    <link rel="manifest" href="../favico/site.webmanifest" />

    <!-- code highlighting stuff -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/vs2015.min.css" integrity="sha512-mtXspRdOWHCYp+f4c7CkWGYPPRAhq9X+xCvJMUBVAb6pqA4U8pxhT3RWT3LP3bKbiolYL2CkL1bSKZZO4eeTew==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/highlight.min.js" integrity="sha512-6yoqbrcLAHDWAdQmiRlHG4+m0g/CT/V9AGyxabG8j7Jk8j3r3K6due7oqpiRMZqcYe9WM2gPcaNNxnl2ux+3tA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/c.min.js" integrity="sha512-Ny9z3+WJkmC2xW098BNYhPajzsf8iBika/+58Mh4lHCF/it92UR32xhytP4I/yxKmF1fkcEgIF87qbGyz1nmDQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>hljs.highlightAll();</script>
    
    <!-- custom styling -->
    <link rel="stylesheet" href="../css/blog.css">

    <!-- For equations -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Cloudflare Web Analytics -->
    <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "c4b2320f0ee04848bb6f51954d84c0d8"}'></script>
    <!-- End Cloudflare Web Analytics -->

    <!-- Reading progress -->
    <script defer src="../js/progressBar.js"></script>
</head>
<body>
    <!-- PROGRESS BAR -->
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <!-- SIMPLE NAV -->
    <span class="home-btn"><a href="/">Home Page</a></span>

    <!-- TITLE -->
    <h1>The Fall of the House of Vulkan</h1>

    <!-- DATE -->
    <p>xx/xx/2025</p>

    <!-- PROLOGUE -->
    <h2 id="prologue">Prologue</h2>
    <article>
    <p>
        <i>
            During the whole of a dull, dark, and soundless day in the autumn of the year, when the clouds hung oppressively low in the heavens,
            I had been programming alone, on a laptop, a singularly dreary project; and at length found myself, as the shades of the evening
            drew on, within view of the interpolated triangle. I know not how it was, but, with the first glimpse of the API,
            a sense of insufferable doom pervaded my spirit.
        </i>
    </p>
    <p>
        Take a look at this image:
    </p>
    <p>
        <a href="https://en.wikipedia.org/wiki/Utah_teapot#/media/File:Utah_teapot_simple_2.png" target="_blank"><img alt="3D render of the Utah teapot" src="https://upload.wikimedia.org/wikipedia/commons/5/5f/Utah_teapot_simple_2.png"></a>
    </p>
    <p>
        What is it?
    </p>
    <p>
        Well, it's a teapot.
    </p>
    <p>
        Is it <em>real</em>?
    </p>
    <p>
        Of course not.
    </p>
    <p>
        This teapot was <em>inspired</em> by a <a href="https://en.wikipedia.org/wiki/Utah_teapot#/media/File:Original_Utah_Teapot.jpg" target="_blank">real teapot</a>,
        but, alas, the image above is <em>not</em> the image of a real teapot.
        It's an imitation, an artificial reproduction, a simulacrum, and a convincing one at that.
    </p>
    <p>
        Does it matter that it is <em>not</em> real? What is the difference between the real and the fake?
    </p>
    <p>
        I'm not here to discuss <a href="https://a.co/d/5n0AdIY" target="_blank">philosophy</a>.
    </p>
    <p>
        No, I'm here to tell you something more important:
    </p>
    <p>
        <em>You have been scammed.</em>
    </p>
    <p>
        A trillion-dollar industry has convinced you that you need to pay <a href="https://www.amazon.com/s?k=rtx+4090" target="_blank">thousands of dollars</a> to create your own simulacra.
    </p>
    <p>
        And that you also need to write a <a href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/triangle/triangle.cpp" target="_blank">thousand lines</a> of code just to see a single triangle.
    </p>
    <p>
        <a href="https://www.reddit.com/r/GraphicsProgramming/comments/103lrc9/they_took_us_for_absolute_fools/" target="_blank"><img alt="Stop doing graphics programming" src="../img/stop_doing_graphics.png"></a>
    </p>
    <p>
        I am here to tell you that there's another way. That you can do all that by yourself.
    </p>
    <p>
        I know you already think of me as a hero, and I accept this responsibility.
    </p>
    <p>
        So bring up your terminal, open your favorite text editor, and let's make our own simulator.
        You may use an <a href="https://www.learncpp.com/cpp-tutorial/installing-an-integrated-development-environment-ide/" target="_blank">IDE</a> if you wish.
        I am not here to teach you all the technicalities involved
        in compiling and linking the source code&mdash;you will have to learn that <a href="https://www.learncpp.com/cpp-tutorial/compiling-your-first-program/" target="_blank">somewhere else</a>.
        Nor will I teach you how to program in <a href="https://a.co/d/8qRAAeX" target="_blank">C</a>.
        But I <em>will</em> teach you the computer science behind generating images like the teapot above.
        No GPUs or <a href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html" target="_blank">convoluted APIs</a> are needed. There is a great joy in writing your own computer graphics code from scratch,
        and my hope is to deliver that joy to <em>you</em>.
    </p>
    </article>

    <!-- FIRST PRINCIPLES -->
    <h2 id="first-principles">First Principles</h2>
    <article>
    <p>
        What is the first step in creating our own <a href="https://en.wikipedia.org/wiki/The_Matrix" target="_blank">matrix</a>?
        We don't just want to build a general-purpose simulation, we want to <em>experience it</em>, too.
        That means we need some sort of a portal into another dimension&mdash;a <a href="https://narnia.fandom.com/wiki/Wardrobe" target="_blank">wardrobe</a> that opens to Narnia.
        There are different ways of accomplishing this. One of them is by creating an image, and then displaying it on an image viewer.
        But there are <a href="https://en.wikipedia.org/wiki/Image_file_format#Major_graphic_file_formats" target="_blank">so many</a> image formats, which one to choose?
    </p>
    <p>
        One of the simplest image formats is <a href="https://en.wikipedia.org/wiki/Netpbm" target="_blank">PPM</a>.
        Here's an example from wikipedia:
        <table>
            <tr>
                <td>P3</td>
            </tr>
            <tr>
                <td>3</td>
                <td>2</td>
            </tr>
            <tr>
                <td>255</td>
            </tr>
            <tr>
                <td>255</td>
                <td>0</td>
                <td>0</td>
            </tr>
            <tr>
                <td>0</td>
                <td>255</td>
                <td>0</td>
            </tr>
            <tr>
                <td>0</td>
                <td>0</td>
                <td>255</td>
            </tr>
            <tr>
                <td>255</td>
                <td>255</td>
                <td>0</td>
            </tr>
            <tr>
                <td>255</td>
                <td>255</td>
                <td>255</td>
            </tr>
            <tr>
                <td>0</td>
                <td>0</td>
                <td>0</td>
            </tr>
        </table>
    </p>
    <p>
        <strong>P3</strong> denotes that this is an <a href="https://en.wikipedia.org/wiki/ASCII" target="_blank">ASCII</a> file.
        <strong>3</strong> and <strong>2</strong> are the width and the height of the image, respectively.
        <strong>255</strong> on the next line means <em>"end of header"</em>. That is, everything that comes after this line are the actual colors of the image&mdash;which we discuss next.
    </p>
    <p>
        What <i>is</i> <strong>color</strong>? This may shock you when I say this, but, colors aren't <em>real</em>. They don't actually exist.
        Colors are no more real than the Santa Claus who gifts you presents (or coal!) every Christmas.
        We all partake in a great conspiracy when we open our eyes and <em>see</em>. Colors form an important part of our shared hallucination of the world,
        alongside money and religion. It's funny when you think about it: the teapot that you "saw" earlier is a lie that approximates another lie
        concocted by the buzzing of neurons inside your <a href="https://en.wikipedia.org/wiki/Visual_cortex" target="_blank">visual cortex</a>.
    </p>
    <p>
        In the real world we have something called <a href="https://en.wikipedia.org/wiki/Electromagnetic_spectrum" target="_blank">the electromagnetic spectrum</a>,
        only a small part of which makes up the wavelengths that the human eye can see:
    </p>
    <p>
        <img alt="Electromagnetic spectrum" src="../img/spectrum.svg">
    </p>
    <p>
        Worse, the cells within your eye have different sensitivities to different parts of the visible spectrum.
        The image below (which I yoinked from <a href="https://www.simplypsychology.org/what-is-the-trichromatic-theory-of-color-vision.html" target="_blank">simplepsychology.org</a>)
        illustrates this nicely: 
    </p>
    <p>
        <img alt="Human color sensitivities" src="../img/eye-color-sensitivity.webp">
    </p>
    <p>
        The human eye is more sensitive to some colors than others, i.e. you may see some colors <em>"brighter"</em> than others (assuming that you're a human reading this page).
        Also, due to the awkward wiring of the optical nerve, you have been gifted a blind spot:
    </p>
    <p>
        <img alt="Human eye blind spot" src="../img/blind-spot.jpg">
    </p>
    <p>
        <i>"But... I don't see any dark patches in my vision?!"</i>, you might say.
        Well, thanks to this error made by the clunky hand of evolution,
        your brain now has to compensate by literally <a href="https://en.wikipedia.org/wiki/Blind_spot_(vision)" target="_blank">filling in</a> the void.
        Life decided that it would rather hallucinate than to actually see.
    </p>
    <p>
        You live inside your very own <a href="https://en.wikipedia.org/wiki/Metaverse" target="_blank">Metaverse</a>,
        powered by the three pounds of flesh in your skull.
    </p>
    <p>
        By the way, cephalopods <a href="https://youtu.be/HATW8xJMxAc?si=E_YykDNmXw-hIPkN" target="_blank">don't have this problem</a>.
    </p>
    <p>
        Christians were right all along&mdash;we really <em>are</em> made in the image of our <a href="https://en.wikipedia.org/wiki/The_Blind_Watchmaker" target="_blank">Creator</a>.
    </p>
    <p>
        What I want you to get from all this is that everything that you see is fake: you are fake, I am fake, your Mom is fake...
    </p>
    <p>
        As long as our delusions don't harm the reproductive success of our species, they will persist,
        and we seem to be the only species who use technology to indulge ourselves in artificial delusions.
        We went from <a href="https://en.wikipedia.org/wiki/Lascaux" target="_blank">cave paintings</a> to <a href="https://youtu.be/dYk7byKHSRw?feature=shared" target="_blank">this</a>
        in the blink of an eye (in cosmological timescales).
        There is clearly great value in running simulations, especially those that we get to <em>experience</em>.
        There are philosophers who think the simulation is <a href="https://simulation-argument.com/" target="_blank">the final technology</a>.
    </p>
    <p>
        That being said, the chicanery of light and color is too complex for computers to handle
        (especially when we want to generate images <em>fast</em>).
        Instead what we do is take the visible part of the electromagnetic spectrum and quantize it based on the intensity of three colors:
        <span style="color: red;">RED</span>, <span style="color: green;">GREEN</span>, and <span style="color: blue;">BLUE</span>&mdash;to
        the much chagrin of <a href="https://en.wikipedia.org/wiki/Tetrachromacy" target="_blank">tetrachromats</a>.
        We represent each of these intensities as an 8-bit unsigned integer between 0 and 255.
        This gives us a total of 256 * 256 * 256 = 16777216 (~16 million) colors to work with. Not bad.
    </p>
    <p>
        Take a look at that PPM image again. The first row is:
    </p>
    <p>
        <table>
            <tr>
                <td>255</td>
                <td>0</td>
                <td>0</td>
            </tr>
        </table>
    </p>
    <p>
        This array of numbers represents the <span style="color: red;">RED</span> color.
        The next row is:
    </p>
    <p>
        <table>
            <tr>
                <td>0</td>
                <td>255</td>
                <td>0</td>
            </tr>
        </table>
    </p>
    <p>
        This is the <span style="color: green;">GREEN</span> color.
        When we <em>interpret</em> the color data together with the width and the height of the image, we get the following picture:
    </p>
    <p>
        <img alt="PPM image example" src="../img/ppm.svg">
    </p>
    <p>
        We now know that to generate images we will need a structure that stores width, height, and an array of numbers that represents the colors.
        So, let us do that:
    </p>
    <details>
        <summary>Click to see the code</summary>
    <pre><code class="mono">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef struct
{
    uint8_t x;
    uint8_t y;
    uint8_t z;
    uint8_t w;
}
CgVec4U8;

typedef struct
{
    uint32_t width;
    uint32_t height;
    uint32_t* pixels;
}
CgColorBufferU32;

CgColorBufferU32 cgCreateColorBufferU32(uint32_t width,
                                        uint32_t height)
{
    assert(width &gt; 0 &amp;&amp; height &gt; 0 &amp;&amp; "cgCreateColorBufferU32: width or height is zero");

    CgColorBufferU32 colorBuffer = {};
    colorBuffer.width = width;
    colorBuffer.height = height;
    colorBuffer.pixels = malloc(width * height * sizeof(uint32_t));
    if (!colorBuffer.pixels) {
        perror("cgCreateColorBufferU32::malloc:");
        exit(EXIT_FAILURE);
    }
    return colorBuffer;
}

void cgClearColorBufferU32(CgColorBufferU32* colorBuffer,
                           CgVec4U8 color)
{
    assert(colorBuffer &amp;&amp; "cgClearColorBufferU32: colorBuffer is NULL");

    uint32_t pixel = ((uint32_t)color.x) |
                     ((uint32_t)color.y &lt;&lt; 8) |
                     ((uint32_t)color.z &lt;&lt; 16) |
                     ((uint32_t)color.w &lt;&lt; 24);

    uint32_t resolution = colorBuffer-&gt;width * colorBuffer-&gt;height;
    for (uint32_t i = 0; i &lt; resolution; ++i) {
        colorBuffer-&gt;pixels[i] = pixel;
    }
}

void cgColorBufferU32ToPPM(const CgColorBufferU32* colorBuffer,
                           const char* path)
{
    assert(colorBuffer &amp;&amp; "cgColorBufferU32ToPPM: colorBuffer is NULL");
    assert(path &amp;&amp; "cgColorBufferU32ToPPM: path is NULL");

    FILE* fp = fopen(path, "w");
    if (!fp) {
        perror("cgColorBufferU32ToPPM::fopen:");
        exit(EXIT_FAILURE);
    }
    fprintf(fp, "P3\n");
    fprintf(fp, "%u %u\n", colorBuffer-&gt;width, colorBuffer-&gt;height);
    fprintf(fp, "255\n");
    uint32_t resolution = colorBuffer-&gt;width * colorBuffer-&gt;height;
    for (uint32_t i = 0; i &lt; resolution; ++i) {
        uint32_t pixel = colorBuffer-&gt;pixels[i];
        uint8_t red = *((uint8_t*)&amp;pixel + 0);
        uint8_t green = *((uint8_t*)&amp;pixel + 1);
        uint8_t blue = *((uint8_t*)&amp;pixel + 2);
        fprintf(fp, "%u %u %u\n", red, green, blue);
    }
    fclose(fp);
}

int main()
{
    uint32_t width = 320;
    uint32_t height = 240;
    CgVec4U8 clearColor = { 255, 150, 255, 255 };
    CgColorBufferU32 colorBuffer = cgCreateColorBufferU32(width, height);
    cgClearColorBufferU32(&amp;colorBuffer, clearColor);
    cgColorBufferU32ToPPM(&amp;colorBuffer, "sample.ppm");
    return 0;
}</code></pre>
    </details>
    <p>
        Running the code above creates the image below:
    </p>
    <p>
        <img alt="Output of the code" src="../img/cursedgl_0.png">
    </p>
    <p>
        I converted the PPM to <a href="https://en.wikipedia.org/wiki/PNG" target="_blank">PNG</a> since web browsers can't render PPM images
        (maybe some can, but <a href="https://www.mozilla.org/en-US/firefox/" target="_blank">firefox</a> couldn't).
    </p>
    <p>
        There is a long way to go before our image starts to look like a teapot. But we already have the fundamental structures:
    </p>
    <pre><code class="mono">typedef struct
{
    uint8_t x;
    uint8_t y;
    uint8_t z;
    uint8_t w;
}
CgVec4U8;</code></pre>
    <p>
        Since C doesn't have namespaces, I name my structures with a two-letter identifier <strong>Cg</strong> to prevent naming conflicts.
        Here, <strong>Cg</strong> stands for "Computer graphics", but you may use your own naming scheme if you wish.
        Next, <strong>Vec4</strong> stands for the 4-dimensional vector
        (if you need some refreshing on vectors, <a href="https://www.realtimerendering.com/" target="_blank">realtimerendering.com</a>
        has a nice <a href="https://www.realtimerendering.com/Real-Time_Rendering_4th-Appendices.pdf" target="_blank">PDF</a> that you can read).
        Finally, I indicate the type of the elements in the structure: <strong>U8</strong>, which stands for 8-bit unsigned integer.
    </p>
    <p>
        Therefore, a 4D floating-point vector can be defined as <strong>CgVec4F32</strong>:
    </p>
    <pre><code class="mono">typedef struct
{
    float x;
    float y;
    float z;
    float w;
}
CgVec4F32;</code></pre>
    <p>
        The struct <strong>CgColorBufferU32</strong> follows the same convention.
        After all, we need a place to <em>store</em> the image, so we will use the <strong>pixels</strong> pointer
        to refer to some place in memory where the image is stored:
    </p>
    <pre><code class="mono">typedef struct
{
    uint32_t width;
    uint32_t height;
    uint32_t* pixels;
}
CgColorBufferU32;</code></pre>
    <p>
        Each pixel is defined as an unsigned 32-bit integer (8-bit per channel, with an additional 8-bit alpha channel that we will discuss later).
    </p>
    <p>
        Then we define the <strong>cgCreateColorBufferU32</strong> function that allocates a new buffer to store the image.
        Note that the <strong>cgCreateColorBufferU32</strong> doesn't <em>initialize</em> the buffer,
        it only <em>allocates</em> enough memory to <em>store</em> the image.
        This goes against the <strong>"never forget initializing your variables"</strong> mantra, but
        the values of a newly-allocated color buffer are likely to be immediately discarded and/or written to anyway,
        so it doesn't really make sense to initialize it with some default color value.
        Instead we have another function that updates the color buffer given a single color:
        <strong>cgClearColorBufferU32</strong>. Note how the 32-bit pixels are generated:
    </p>
    <pre><code class="mono">uint32_t pixel = ((uint32_t)color.x) |
                 ((uint32_t)color.y &lt;&lt; 8) |
                 ((uint32_t)color.z &lt;&lt; 16) |
                 ((uint32_t)color.w &lt;&lt; 24);</code></pre>
    <p>
        Here the <strong>x</strong>, <strong>y</strong>, <strong>z</strong>, <strong>w</strong>
        values correspond to the <span style="color: red;">red</span>, <span style="color: green;">green</span>,
        <span style="color: blue;">blue</span>, and <span>alpha</span> values.
        What is <em>alpha</em>? Roughly speaking, the alpha represents the transparency of the image.
        That is to say, if there was <em>another</em> image behind <em>our</em> image, then the alpha values
        of our image would determine <em>the extent to which</em> the colors of the background image would <em>bleed through</em> our image.
        This description is a little abstract, but don't worry, we will look at transparency in more detail later.
    </p>
    <p>
        Each <strong>uint32_t pixel</strong> stores the red value in its least significant 8 bits
        (assuming that we are programming in a <a href="https://en.wikipedia.org/wiki/Endianness" target="_blank">little-endian</a> machine).
        Why? For no particular reason. Different applications may use different pixel layouts, and switching between layouts is trivial.
        But once the layout is determined, we have to be consistent, and we are: our function <strong>cgColorBufferU32ToPPM</strong>
        assumes the red will be found in the least significant 8 bits of the given <strong>uint32_t</strong> value:
    </p>
    <pre><code class="mono">uint32_t pixel = colorBuffer-&gt;pixels[i];
uint8_t red = *((uint8_t*)&amp;pixel + 0);
uint8_t green = *((uint8_t*)&amp;pixel + 1);
uint8_t blue = *((uint8_t*)&amp;pixel + 2);
fprintf(fp, "%u %u %u\n", red, green, blue);</code></pre>
    <p>
        An image with a single color is kind of boring though. We can write another function <strong>cgGradientColorBufferU32</strong>
        that draws a gradient across the image:
    </p>
    <pre><code class="mono">void cgGradientColorBufferU32(CgColorBufferU32* colorBuffer,
                              CgVec4U8 topLeftColor,
                              CgVec4U8 topRightColor,
                              CgVec4U8 bottomLeftColor,
                              CgVec4U8 bottomRightColor)
{
    assert(colorBuffer &amp;&amp; "cgGradientColorBufferU32: colorBuffer is NULL");

    CgVec4F32 topLeftColorF32 = cgConvertVec4U8ToF32(topLeftColor);
    CgVec4F32 topRightColorF32 = cgConvertVec4U8ToF32(topRightColor);
    CgVec4F32 bottomLeftColorF32 = cgConvertVec4U8ToF32(bottomLeftColor);
    CgVec4F32 bottomRightColorF32 = cgConvertVec4U8ToF32(bottomRightColor);

    for (uint32_t i = 0; i &lt; colorBuffer-&gt;width; ++i) {
        float x = (float)i / (float)colorBuffer-&gt;width;
        for (uint32_t j = 0; j &lt; colorBuffer-&gt;height; ++j) {
            float y = (float)j / (float)colorBuffer-&gt;height;

            CgVec4F32 topColor = cgLerpVec4F32(topLeftColorF32, topRightColorF32, x);
            CgVec4F32 bottomColor = cgLerpVec4F32(bottomLeftColorF32, bottomRightColorF32, x);
            CgVec4F32 finalColor = cgLerpVec4F32(topColor, bottomColor, y);

            CgVec4U8 color = cgConvertVec4F32ToU8(finalColor);
            uint32_t pixel = cgConvertVec4U8ToU32(color);
            colorBuffer-&gt;pixels[j * colorBuffer-&gt;width + i] = pixel;
        }
    }
}</code></pre>
    <p>
        We can create gradients by <em>linearly interpolating</em> between the given color values.
        To understand linear interpolation better let us interpolate between two real values, say <strong>a</strong>
        and <strong>b</strong>. We can define <strong>k</strong> as another real value,
        between 0.0 and 1.0, that denotes the <em>amount</em> of interpolation to do.
        You can think of <strong>k</strong> as the <em>distance</em> to travel from
        <strong>a</strong> to <strong>b</strong>.
        When <strong>k</strong> equals 0, we don't travel at all, so we return <strong>a</strong>.
        When <strong>k</strong> equals 1, then we travel the full distance, and thus we return <strong>b</strong>.
        If <strong>k</strong> equals 0.5, then we travel half the distance, so return the half of <strong>a</strong>
        plus the half of <strong>b</strong>.
    </p>
    <p>
        In our case we are trying to interpolate across a two-dimensional surface (our image), so we have two <strong>k</strong>s.
        We can calculate these <strong>k</strong>s by dividing the position of the current pixel
        (<strong>i</strong> and <strong>j</strong>) by the width and the height of our image.
        This works because <strong>i</strong> will always be between 0 and the width of the image,
        so dividing <strong>i</strong> by the width will always yield a value between 0.0 and 1.0
        (technically speaking, we will never reach 1.0, since <strong>i</strong> will never be the width of the image, but this is okay, because it will get
        very close to 1.0 anyway. If you're bothered by this, you can instead divide by (width - 1), which <em>will</em> produce the correct interpolation).
        The same remark applies to <strong>j</strong>: diving <strong>j</strong> by the height of the image will also produce a value between 0.0 and 1.0.
    </p>
    <p>
        Now we can use these <strong>k</strong>s to linearly interpolate between the given color values.
        Because <strong>k</strong>s are floating-point values, it's best that we convert our colors to their
        floating-point equivalents as well, lest we litter the codebase with <a href="https://stackoverflow.com/questions/7558837/what-exactly-is-a-type-cast-in-c-c" target="_blank">type casts</a>.
        Instead we bury the casts in functions, e.g. with <strong>cgConvertVec4U8ToF32</strong>:
    </p>
    <pre><code class="mono">CgVec4F32 cgConvertVec4U8ToF32(CgVec4U8 v)
{
    CgVec4F32 r = { .x = (float)v.x,
                    .y = (float)v.y,
                    .z = (float)v.z,
                    .w = (float)v.w };
    return r;
}</code></pre>
    <p>
        The linear interpolation is computed by the <strong>cgLerpVec4F32</strong> function:
    </p>
    <pre><code class="mono">CgVec4F32 cgLerpVec4F32(CgVec4F32 p,
                        CgVec4F32 q,
                        float k)
{
    CgVec4F32 r = {
        .x = (1.0f - k) * p.x + k * q.x,
        .y = (1.0f - k) * p.y + k * q.y,
        .z = (1.0f - k) * p.z + k * q.z,
        .w = (1.0f - k) * p.w + k * q.w
    };
    return r;
}</code></pre>
    <p>
        Notice how when <strong>k</strong> equals 0, we return the first value (<strong>p</strong>),
        and when it equals 1, we return the second value (<strong>q</strong>), and for the remaining values of
        <strong>k</strong> it is a mixture of both.
        Once interpolated, we convert the <strong>CgVec4F32</strong> back to <strong>CgVec4U8</strong>
        using <strong>cgConvertVec4F32ToU8</strong>:
    </p>
    <pre><code class="mono">CgVec4U8 cgConvertVec4F32ToU8(CgVec4F32 v)
{
    CgVec4U8 r = { .x = (uint8_t)v.x,
                   .y = (uint8_t)v.y,
                   .z = (uint8_t)v.z,
                   .w = (uint8_t)v.w };
    return r;
}</code></pre>
    <p>
        But since we store pixels as <strong>uint32_t</strong> values, we need to convert our <strong>CgVec4U8</strong>
        to a 32-bit unsigned integer via <strong>cgConvertVec4U8ToU32</strong>:
    </p>
    <pre><code class="mono">uint32_t cgConvertVec4U8ToU32(CgVec4U8 color)
{
    uint32_t pixel = ((uint32_t)color.x) |
                     ((uint32_t)color.y &lt;&lt; 8) |
                     ((uint32_t)color.z &lt;&lt; 16) |
                     ((uint32_t)color.w &lt;&lt; 24);
    return pixel;
}</code></pre>
    <p>
        If we use <span style="color: red;">RED</span> for the top-left color,
        <span style="color: green;">GREEN</span> for the top-right color,
        <span style="color: blue;">BLUE</span> for the bottom-left color, and
        <span style="color: yellow;">YELLOW</span> for the bottom-right color, then <strong>cgGradientColorBufferU32</strong> will produce the following image:
    </p>
    <p>
        <img alt="Output of the code" src="../img/cursedgl_1.png">
    </p>
    <p>
        You need to understand interpolation <em>well</em>, because we will use it again, albeit for a different geometry.
        The full source code is below:
    </p>
    <details>
        <summary>Click to see the code</summary>
    <pre><code class="mono">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef struct
{
    uint8_t x;
    uint8_t y;
    uint8_t z;
    uint8_t w;
}
CgVec4U8;

typedef struct
{
    float x;
    float y;
    float z;
    float w;
}
CgVec4F32;

CgVec4F32 cgConvertVec4U8ToF32(CgVec4U8 v)
{
    CgVec4F32 r = { .x = (float)v.x,
                    .y = (float)v.y,
                    .z = (float)v.z,
                    .w = (float)v.w };
    return r;
}

CgVec4U8 cgConvertVec4F32ToU8(CgVec4F32 v)
{
    CgVec4U8 r = { .x = (uint8_t)v.x,
                   .y = (uint8_t)v.y,
                   .z = (uint8_t)v.z,
                   .w = (uint8_t)v.w };
    return r;
}

uint32_t cgConvertVec4U8ToU32(CgVec4U8 color)
{
    uint32_t pixel = ((uint32_t)color.x) |
                     ((uint32_t)color.y &lt;&lt; 8) |
                     ((uint32_t)color.z &lt;&lt; 16) |
                     ((uint32_t)color.w &lt;&lt; 24);
    return pixel;
}

CgVec4F32 cgLerpVec4F32(CgVec4F32 p,
                        CgVec4F32 q,
                        float k)
{
    CgVec4F32 r = {
        .x = (1.0f - k) * p.x + k * q.x,
        .y = (1.0f - k) * p.y + k * q.y,
        .z = (1.0f - k) * p.z + k * q.z,
        .w = (1.0f - k) * p.w + k * q.w
    };
    return r;
}

typedef struct
{
    uint32_t width;
    uint32_t height;
    uint32_t* pixels;
}
CgColorBufferU32;

CgColorBufferU32 cgCreateColorBufferU32(uint32_t width,
                                        uint32_t height)
{
    assert(width &gt; 0 &amp;&amp; height &gt; 0 &amp;&amp; "cgCreateColorBufferU32: width or height is zero");

    CgColorBufferU32 colorBuffer = {};
    colorBuffer.width = width;
    colorBuffer.height = height;
    colorBuffer.pixels = malloc(width * height * sizeof(uint32_t));
    if (!colorBuffer.pixels) {
        perror("cgCreateColorBufferU32::malloc:");
        exit(EXIT_FAILURE);
    }
    return colorBuffer;
}

void cgClearColorBufferU32(CgColorBufferU32* colorBuffer,
                           CgVec4U8 color)
{
    assert(colorBuffer &amp;&amp; "cgClearColorBufferU32: colorBuffer is NULL");

    uint32_t pixel = cgConvertVec4U8ToU32(color);
    uint32_t resolution = colorBuffer-&gt;width * colorBuffer-&gt;height;
    for (uint32_t i = 0; i &lt; resolution; ++i) {
        colorBuffer-&gt;pixels[i] = pixel;
    }
}

void cgGradientColorBufferU32(CgColorBufferU32* colorBuffer,
                              CgVec4U8 topLeftColor,
                              CgVec4U8 topRightColor,
                              CgVec4U8 bottomLeftColor,
                              CgVec4U8 bottomRightColor)
{
    assert(colorBuffer &amp;&amp; "cgGradientColorBufferU32: colorBuffer is NULL");

    CgVec4F32 topLeftColorF32 = cgConvertVec4U8ToF32(topLeftColor);
    CgVec4F32 topRightColorF32 = cgConvertVec4U8ToF32(topRightColor);
    CgVec4F32 bottomLeftColorF32 = cgConvertVec4U8ToF32(bottomLeftColor);
    CgVec4F32 bottomRightColorF32 = cgConvertVec4U8ToF32(bottomRightColor);

    for (uint32_t i = 0; i &lt; colorBuffer-&gt;width; ++i) {
        float x = (float)i / (float)colorBuffer-&gt;width;
        for (uint32_t j = 0; j &lt; colorBuffer-&gt;height; ++j) {
            float y = (float)j / (float)colorBuffer-&gt;height;

            CgVec4F32 topColor = cgLerpVec4F32(topLeftColorF32, topRightColorF32, x);
            CgVec4F32 bottomColor = cgLerpVec4F32(bottomLeftColorF32, bottomRightColorF32, x);
            CgVec4F32 finalColor = cgLerpVec4F32(topColor, bottomColor, y);

            CgVec4U8 color = cgConvertVec4F32ToU8(finalColor);
            uint32_t pixel = cgConvertVec4U8ToU32(color);
            colorBuffer-&gt;pixels[j * colorBuffer-&gt;width + i] = pixel;
        }
    }
}

void cgColorBufferU32ToPPM(const CgColorBufferU32* colorBuffer,
                           const char* path)
{
    assert(colorBuffer &amp;&amp; "cgColorBufferU32ToPPM: colorBuffer is NULL");
    assert(path &amp;&amp; "cgColorBufferU32ToPPM: path is NULL");

    FILE* fp = fopen(path, "w");
    if (!fp) {
        perror("cgColorBufferU32ToPPM::fopen:");
        exit(EXIT_FAILURE);
    }
    fprintf(fp, "P3\n");
    fprintf(fp, "%u %u\n", colorBuffer-&gt;width, colorBuffer-&gt;height);
    fprintf(fp, "255\n");
    uint32_t resolution = colorBuffer-&gt;width * colorBuffer-&gt;height;
    for (uint32_t i = 0; i &lt; resolution; ++i) {
        uint32_t pixel = colorBuffer-&gt;pixels[i];
        uint8_t red = *((uint8_t*)&amp;pixel + 0);
        uint8_t green = *((uint8_t*)&amp;pixel + 1);
        uint8_t blue = *((uint8_t*)&amp;pixel + 2);
        fprintf(fp, "%u %u %u\n", red, green, blue);
    }
    fclose(fp);
}

int main()
{
    uint32_t width = 320;
    uint32_t height = 240;
    CgColorBufferU32 colorBuffer = cgCreateColorBufferU32(width, height);
    CgVec4U8 topLeftColor = { 255, 0, 0, 255 };
    CgVec4U8 topRightColor = { 0, 255, 0, 255 };
    CgVec4U8 bottomLeftColor = { 0, 0, 255, 255 };
    CgVec4U8 bottomRightColor = { 255, 255, 0, 255 };
    cgGradientColorBufferU32(&amp;colorBuffer, topLeftColor, topRightColor, bottomLeftColor, bottomRightColor);
    cgColorBufferU32ToPPM(&amp;colorBuffer, "sample.ppm");
    return 0;
}
    </code></pre>
    </details>
    <p>
        By the way, the astute amongst you might have noticed an inconsistency in the naming. Namely, <strong>cgConvertVec4U8ToU32</strong>
        doesn't return a <strong>CgVec4U32</strong> (we haven't even defined it!), instead it returns a plain <strong>uint32_t</strong>. You may fix this
        by renaming <strong>cgConvertVec4U8ToU32</strong> to a more apt <strong>cgConvertVec4U8ToU32Scalar</strong>.
    </p>
    </article>

    <!-- FLOATING-POINT BUFFERS -->
    <h2 id="floating-point-buffers">Floating-point Buffers</h2>
    <article>
    <p>
        So far we have been storing our color values in <strong>CgColorBufferU32</strong>,
        and while there isn't anything inherently wrong with 8-bit colors, it is often much easier to work
        with floating-point values. We have already seen this in the <strong>cgGradientColorBufferU32</strong>
        function. Linear interpolation works best with floating-point values as the <em>amount to interpolate</em> between two values
        is given by a real number between 0.0 and 1.0. In our case we could have simply defined a <strong>uint8_t</strong>
        variant of the <strong>cgLerpVec4F32</strong> function, but there are reasons other than casting.
        Many interesting computer graphics algorithms work best with floating-point numbers. One of them is <em>gamma correction</em>.
    </p>
    <p>
        A problem that we are facing now is that our colors are <em>wrong</em>. We talked about how the human eye is more sensitive
        to certain colors than others. Well, it turns out that our eyes become more sensitive to light in <em>darker</em> environments, too.
        I don't exactly know why this is the case, but it could be an evolutionary adaptation to increase chances of survival
        for our ancestors living amongst nocturnal predators.
    </p>
    <p>Look at the image below that I yoinked from <a href="https://learnopengl.com" target="_blank">learnopengl.com</a>
        (there will be a lot of yoinking in this article&#8212standing on the shoulders of giants or something):
    </p>
    <p>
        <img alt="Perceived vs physical brightness" src="../img/gamma-correction.png">
    </p>
    <p>
        Looking at the physical brightness values, they don't seem to be evenly-spaced, even though they are.
        There is only a constant amount of difference between the colors of the boxes in the physical brightness row,
        even though it doesn't look that way. In contrast, the difference between the colors of the boxes in the
        perceived brightness row <em>varies</em>, and yet the difference <em>seems</em> constant.
        Alas, our delusions triumph, and our hallucinations gain an upper hand.
        To satisfy our false perceptions, we must map the physical brightness to perceived brightness, lest the colors will look wrong.
        This mapping is defined by a <a href="https://en.wikipedia.org/wiki/Power_law" target="_blank">power law</a>:
    </p>
    <p style="text-align: center;">
        \( C_{gamma} = {C_{linear}}^{k} \) <span style="float: right;">(1)</span>
    </p>
    <p>
        Here \(C_{linear} \) is the color that we generated using <strong>cgGradientColorBufferU32</strong>, but the actual color on the screen
        will be \(C_{gamma} \). Think about it for a second. Because we used values between 0 and 255 to represent our color values,
        you may conclude that \(C_{gamma} \) for a color value of 128 will be 16384 (assuming <strong>k</strong> is 2), but this is not the case.
        (1) is defined for color values between 0.0 and 1.0, so a value of 128 will actually be 0.5&mdash;when you raise 0.5 to the power of 2,
        you get 0.25, a lower value! Therefore, the output of <strong>cgGradientColorBufferU32</strong> will look <em>dimmer</em>.
    </p>
    <p>
        The solution is to store our colors <em>after</em> applying <em>gamma correction</em>, which we do by raising the output of
        <strong>cgGradientColorBufferU32</strong> to the <em>inverse</em> of <strong>k</strong>:
    </p>
    <p style="text-align: center;">
        \(C_{encoded} = {C_{linear}}^{1/k} \) <span style="float: right;">(2)</span>
    </p>
    <p>
        Later, when \(C_{encoded} \) goes through (1), the powers cancel out, and we end up with the correct colors,
        since for any value \( x \) we have \( ({{x}^{1/k}})^{k} = x^1 = x \).
    </p>
    <p>
        Unfortunately, <strong>cgGradientColorBufferU32</strong> produces <strong>uint32_t</strong> colors that store the
        <span style="color:red;">red</span>, <span style="color: green;">green</span>, and <span style="color: blue;">blue</span> components
        as <strong>uint8_t</strong> values,
        but (2) assumes that \(C_{linear} \) is a floating-point value between 0.0 and 1.0.
        Instead of using unsigned integers, we will
        represent the components of our colors as floating-point values between 0.0 and 1.0. Let's see how that looks in practice. First, we define
        a floating-point variant of <strong>CgColorBufferU32</strong>:
    </p>
    <pre><code class="mono">typedef struct
{
    uint32_t width;
    uint32_t height;
    CgVec4F32* pixels;
}
CgColorBufferF32;</code></pre>
    <p>
        Then we write another function, <strong>cgCreateColorBufferF32</strong>, to allocate memory for our floating-point buffer:
    </p>
    <pre><code class="mono">CgColorBufferF32 cgCreateColorBufferF32(uint32_t width,
                                        uint32_t height)
{
    assert(width &gt; 0 &amp;&amp; height &gt; 0 &amp;&amp; "cgCreateColorBufferF32: width or height is zero");

    CgColorBufferF32 colorBuffer = {};
    colorBuffer.width = width;
    colorBuffer.height = height;
    colorBuffer.pixels = malloc(width * height * sizeof(CgVec4F32));
    if (!colorBuffer.pixels) {
        perror("cgCreateColorBufferF32::malloc:");
        exit(EXIT_FAILURE);
    }
    return colorBuffer;
}</code></pre>
    <p>
        We also write the floating-point variant of <strong>cgColorBufferU32ToPPM</strong>, except this time
        we apply gamma correction:
    </p>
    <pre><code class="mono">void cgColorBufferF32ToPPM(const CgColorBufferF32* colorBuffer,
                           const char* path,
                           float gamma)
{
    assert(colorBuffer &amp;&amp; "cgColorBufferF32ToPPM: colorBuffer is NULL");
    assert(path &amp;&amp; "cgColorBufferF32ToPPM: path is NULL");

    FILE* fp = fopen(path, "w");
    if (!fp) {
        perror("cgColorBufferF32ToPPM::fopen:");
        exit(EXIT_FAILURE);
    }
    fprintf(fp, "P3\n");
    fprintf(fp, "%u %u\n", colorBuffer-&gt;width, colorBuffer-&gt;height);
    fprintf(fp, "255\n");
    uint32_t resolution = colorBuffer-&gt;width * colorBuffer-&gtheight;
    for (uint32_t i = 0; i < resolution; ++i) {
        CgVec4F32 pixel = colorBuffer->pixels[i];
        CgVec4F32 gammaEncodedPixel = cgApplyGammaToVec4F32(pixel, gamma);
        uint8_t red = (uint8_t)(gammaEncodedPixel.x * 255.0f);
        uint8_t green = (uint8_t)(gammaEncodedPixel.y * 255.0f);
        uint8_t blue = (uint8_t)(gammaEncodedPixel.z * 255.0f);
        fprintf(fp, "%u %u %u\n", red, green, blue);
    }
    fclose(fp);
}</code></pre>
    <p>
        Below is the definition of <strong>cgApplyGammaToVec4F32</strong>:
    </p>
    <pre><code class="mono">CgVec4F32 cgApplyGammaToVec4F32(CgVec4F32 pixel, float gamma)
{
    assert(gamma != 0.0f &amp;&amp; "cgApplyGammaToVec4F32: gamma cannot be 0");
    CgVec4F32 gammaEncodedPixel = {
        .x = powf(pixel.x, 1.0f / gamma),
        .y = powf(pixel.y, 1.0f / gamma),
        .z = powf(pixel.z, 1.0f / gamma),
        .w = pixel.w
    };
    return gammaEncodedPixel;
}</code></pre>
    <p>
        The floating-point version of <strong>cgGradientColorBufferU32</strong> is:
    </p>
    <pre><code class="mono">void cgGradientColorBufferF32(CgColorBufferF32* colorBuffer,
                              CgVec4F32 topLeftColor,
                              CgVec4F32 topRightColor,
                              CgVec4F32 bottomLeftColor,
                              CgVec4F32 bottomRightColor)
{
    assert(colorBuffer &amp;&amp; "cgGradientColorBufferF32: colorBuffer is NULL");

    for (uint32_t i = 0; i &lt; colorBuffer-&gtwidth; ++i) {
        float x = (float)i / (float)colorBuffer-&gtwidth;
        for (uint32_t j = 0; j &lt; colorBuffer-&gtheight; ++j) {
            float y = (float)j / (float)colorBuffer-&gtheight;

            CgVec4F32 topColor = cgLerpVec4F32(topLeftColor, topRightColor, x);
            CgVec4F32 bottomColor = cgLerpVec4F32(bottomLeftColor, bottomRightColor, x);
            CgVec4F32 finalColor = cgLerpVec4F32(topColor, bottomColor, y);

            colorBuffer-&gt;pixels[j * colorBuffer-&gt;width + i] = finalColor;
        }
    }
}</code></pre>
    <p>
        Below is the full source code (don't forget to link the math library):
    </p>
    <details>
        <summary>Click to see the code</summary>
        <pre><code class="mono">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;math.h&gt;

typedef struct
{
    float x;
    float y;
    float z;
    float w;
}
CgVec4F32;

CgVec4F32 cgLerpVec4F32(CgVec4F32 p,
                        CgVec4F32 q,
                        float k)
{
    CgVec4F32 r = {
        .x = (1.0f - k) * p.x + k * q.x,
        .y = (1.0f - k) * p.y + k * q.y,
        .z = (1.0f - k) * p.z + k * q.z,
        .w = (1.0f - k) * p.w + k * q.w
    };
    return r;
}

typedef struct
{
    uint32_t width;
    uint32_t height;
    CgVec4F32* pixels;
}
CgColorBufferF32;

CgColorBufferF32 cgCreateColorBufferF32(uint32_t width,
                                        uint32_t height)
{
    assert(width &gt; 0 &amp;&amp; height &gt; 0 &amp;&amp; "cgCreateColorBufferF32: width or height is zero");

    CgColorBufferF32 colorBuffer = {};
    colorBuffer.width = width;
    colorBuffer.height = height;
    colorBuffer.pixels = malloc(width * height * sizeof(CgVec4F32));
    if (!colorBuffer.pixels) {
        perror("cgCreateColorBufferF32::malloc:");
        exit(EXIT_FAILURE);
    }
    return colorBuffer;
}

void cgGradientColorBufferF32(CgColorBufferF32* colorBuffer,
                              CgVec4F32 topLeftColor,
                              CgVec4F32 topRightColor,
                              CgVec4F32 bottomLeftColor,
                              CgVec4F32 bottomRightColor)
{
    assert(colorBuffer &amp;&amp; "cgGradientColorBufferF32: colorBuffer is NULL");

    for (uint32_t i = 0; i &lt; colorBuffer-&gt;width; ++i) {
        float x = (float)i / (float)colorBuffer-&gt;width;
        for (uint32_t j = 0; j &lt; colorBuffer-&gt;height; ++j) {
            float y = (float)j / (float)colorBuffer-&gt;height;

            CgVec4F32 topColor = cgLerpVec4F32(topLeftColor, topRightColor, x);
            CgVec4F32 bottomColor = cgLerpVec4F32(bottomLeftColor, bottomRightColor, x);
            CgVec4F32 finalColor = cgLerpVec4F32(topColor, bottomColor, y);

            colorBuffer-&gt;pixels[j * colorBuffer-&gt;width + i] = finalColor;
        }
    }
}

CgVec4F32 cgApplyGammaToVec4F32(CgVec4F32 pixel, float gamma)
{
    assert(gamma != 0.0f &amp;&amp; "cgApplyGammaToVec4F32: gamma cannot be 0");
    CgVec4F32 gammaEncodedPixel = {
        .x = powf(pixel.x, 1.0f / gamma),
        .y = powf(pixel.y, 1.0f / gamma),
        .z = powf(pixel.z, 1.0f / gamma),
        .w = pixel.w
    };
    return gammaEncodedPixel;
}

void cgColorBufferF32ToPPM(const CgColorBufferF32* colorBuffer,
                           const char* path,
                           float gamma)
{
    assert(colorBuffer &amp;&amp; "cgColorBufferF32ToPPM: colorBuffer is NULL");
    assert(path &amp;&amp; "cgColorBufferF32ToPPM: path is NULL");

    FILE* fp = fopen(path, "w");
    if (!fp) {
        perror("cgColorBufferF32ToPPM::fopen:");
        exit(EXIT_FAILURE);
    }
    fprintf(fp, "P3\n");
    fprintf(fp, "%u %u\n", colorBuffer-&gt;width, colorBuffer-&gt;height);
    fprintf(fp, "255\n");
    uint32_t resolution = colorBuffer-&gt;width * colorBuffer-&gt;height;
    for (uint32_t i = 0; i &lt; resolution; ++i) {
        CgVec4F32 pixel = colorBuffer-&gt;pixels[i];
        CgVec4F32 gammaEncodedPixel = cgApplyGammaToVec4F32(pixel, gamma);
        uint8_t red = (uint8_t)(gammaEncodedPixel.x * 255.0f);
        uint8_t green = (uint8_t)(gammaEncodedPixel.y * 255.0f);
        uint8_t blue = (uint8_t)(gammaEncodedPixel.z * 255.0f);
        fprintf(fp, "%u %u %u\n", red, green, blue);
    }
    fclose(fp);
}

int main()
{
    uint32_t width = 320;
    uint32_t height = 240;
    float gamma = 2.2f;
    CgColorBufferF32 colorBuffer = cgCreateColorBufferF32(width, height);
    CgVec4F32 topLeftColor = { 1.0f, 0.0f, 0.0f, 1.0f };
    CgVec4F32 topRightColor = { 0.0f, 1.0f, 0.0f, 1.0f };
    CgVec4F32 bottomLeftColor = { 0.0f, 0.0f, 1.0f, 1.0f };
    CgVec4F32 bottomRightColor = { 1.0f, 1.0f, 0.0f, 1.0f };
    cgGradientColorBufferF32(&amp;colorBuffer, topLeftColor, topRightColor, bottomLeftColor, bottomRightColor);
    cgColorBufferF32ToPPM(&amp;colorBuffer, "sample.ppm", gamma);
    return 0;
}
        </code></pre>
    </details>
    <p>
        The question is, what value should we use for <em>gamma</em>? Monitors often use a value around 2.2,
        but I decided to make it a tweakable parameter so that the user can change it. If we use a gamma value
        of 2.2, then the image will look like this:
    </p>
    <p>
        <img alt="Gamma-corrected output" src="../img/cursedgl_2.png">
    </p>
    <p>
        Compare it with the previous image. Notice how the colors are much brighter. Your monitor/OS may use
        a different value for gamma, in which case you may need to adjust it further.
    </p>
    <p>
        I touched only briefly on <em>gamma correction</em>. If you want more, then you may read this
        <a href="https://blog.johnnovak.net/2016/09/21/what-every-coder-should-know-about-gamma" target="_blank">excellent article</a>
        by John Novak, who delves much deeper into the topic, and also shows what happens when your gamma values are incorrect.
    </p>
    </article>

    <h2 id="memory">Memory</h2>
    <article>
    <p>
        Up to this point we have used the standard library routine <strong>malloc</strong> for our memory allocations.
        While there isn't anything inherently wrong with <strong>malloc</strong>, it's more judicious to allow the programmer
        choose her own memory allocation routine. And in case she doesn't, we can easily default back to <strong>malloc</strong>.
    </p>
    <p>
        Another issue with our code is that we don't release the memory that we had allocated
        (this is called <a href="https://en.wikipedia.org/wiki/Memory_leak" target="_blank">memory leak</a>).
        This wasn't really an issue before since our application has been very simple and the OS had no problem cleaning all that mess,
        but going forward we will make sure not to leak any memory.
    </p>
    <p>
        We can solve the first problem by creating a new structure to store pointers to custom allocation/de-allocation routines:
    </p>
    <pre><code class="mono">typedef struct
{
    void* (*allocBytes)(size_t);
    void (*freeBytes)(void*);
}
CgMemoryAllocator;</code></pre>
    <p>
        Then we modify the <strong>cgCreateColorBufferF32</strong> function so that it can use our custom functions instead of
        the previously hard-coded <strong>malloc</strong>:
    </p>
    <pre><code class="mono">CgColorBufferF32 cgCreateColorBufferF32(uint32_t width,
                                        uint32_t height,
                                        CgMemoryAllocator* allocator)
{
    assert(width &gt; 0 &amp;&amp; height &gt; 0 &amp;&amp; "cgCreateColorBufferF32: width or height is zero");
    assert(allocator &amp;&amp; "cgCreateColorBufferF32: allocator is NULL");

    CgColorBufferF32 colorBuffer = {};
    colorBuffer.width = width;
    colorBuffer.height = height;
    colorBuffer.pixels = allocator-&gt;allocBytes(width * height * sizeof(CgVec4F32));
    if (!colorBuffer.pixels) {
        perror("cgCreateColorBufferF32::allocBytes:");
        exit(EXIT_FAILURE);
    }
    return colorBuffer;
}</code></pre>
    <p>
        It may be the case that the programmer prefers to use the default <strong>malloc</strong> function
        (maybe she's too lazy to write her own memory allocator!),
        so we define another function <strong>cgGetDefaultAllocator</strong> as a fallback:
    </p>
    <pre><code class="mono">CgMemoryAllocator* cgGetDefaultAllocator()
{
    static CgMemoryAllocator allocator = {
        .allocBytes = malloc,
        .freeBytes = free
    };
    return &amp;allocator;
}</code></pre>
    <p>
        To solve the second problem, we define another function, called <strong>cgDestroyColorBufferF32</strong>
        that the programmer can use to release the memory allocated for the color buffer:
    </p>
    <pre><code class="mono">void cgDestroyColorBufferF32(CgColorBufferF32* buffer,
                             CgMemoryAllocator* allocator)
{
    assert(buffer &amp;&amp; "cgDestroyColorBufferF32: buffer is NULL");
    assert(allocator &amp;&amp; "cgDestroyColorBufferF32: allocator is NULL");

    allocator-&gt;freeBytes(buffer-&gt;pixels);
    buffer-&gt;width = buffer-&gt;height = 0;
}</code></pre>
    <p>
        In the future we will define our own custom memory allocation functions, and <strong>CgMemoryAllocator</strong>
        will prove more useful than it seems now. The full source code is below.
    </p>
    <details>
        <summary>Click to see the code</summary>
        <pre><code class="mono">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;math.h&gt;

typedef struct
{
    float x;
    float y;
    float z;
    float w;
}
CgVec4F32;

CgVec4F32 cgLerpVec4F32(CgVec4F32 p,
                        CgVec4F32 q,
                        float k)
{
    CgVec4F32 r = {
        .x = (1.0f - k) * p.x + k * q.x,
        .y = (1.0f - k) * p.y + k * q.y,
        .z = (1.0f - k) * p.z + k * q.z,
        .w = (1.0f - k) * p.w + k * q.w
    };
    return r;
}

typedef struct
{
    uint32_t width;
    uint32_t height;
    CgVec4F32* pixels;
}
CgColorBufferF32;

typedef struct
{
    void* (*allocBytes)(size_t);
    void (*freeBytes)(void*);
}
CgMemoryAllocator;

CgMemoryAllocator* cgGetDefaultAllocator()
{
    static CgMemoryAllocator allocator = {
        .allocBytes = malloc,
        .freeBytes = free
    };
    return &amp;allocator;
}

CgColorBufferF32 cgCreateColorBufferF32(uint32_t width,
                                        uint32_t height,
                                        CgMemoryAllocator* allocator)
{
    assert(width &gt; 0 &amp;&amp; height &gt; 0 &amp;&amp; "cgCreateColorBufferF32: width or height is zero");
    assert(allocator &amp;&amp; "cgCreateColorBufferF32: allocator is NULL");

    CgColorBufferF32 colorBuffer = {};
    colorBuffer.width = width;
    colorBuffer.height = height;
    colorBuffer.pixels = allocator-&gt;allocBytes(width * height * sizeof(CgVec4F32));
    if (!colorBuffer.pixels) {
        perror("cgCreateColorBufferF32::allocBytes:");
        exit(EXIT_FAILURE);
    }
    return colorBuffer;
}

void cgDestroyColorBufferF32(CgColorBufferF32* buffer,
                             CgMemoryAllocator* allocator)
{
    assert(buffer &amp;&amp; "cgDestroyColorBufferF32: buffer is NULL");
    assert(allocator &amp;&amp; "cgDestroyColorBufferF32: allocator is NULL");

    allocator-&gt;freeBytes(buffer-&gt;pixels);
    buffer-&gt;width = buffer-&gt;height = 0;
}

void cgGradientColorBufferF32(CgColorBufferF32* colorBuffer,
                              CgVec4F32 topLeftColor,
                              CgVec4F32 topRightColor,
                              CgVec4F32 bottomLeftColor,
                              CgVec4F32 bottomRightColor)
{
    assert(colorBuffer &amp;&amp; "cgGradientColorBufferF32: colorBuffer is NULL");

    for (uint32_t i = 0; i &lt; colorBuffer-&gt;width; ++i) {
        float x = (float)i / (float)colorBuffer-&gt;width;
        for (uint32_t j = 0; j &lt; colorBuffer-&gt;height; ++j) {
            float y = (float)j / (float)colorBuffer-&gt;height;

            CgVec4F32 topColor = cgLerpVec4F32(topLeftColor, topRightColor, x);
            CgVec4F32 bottomColor = cgLerpVec4F32(bottomLeftColor, bottomRightColor, x);
            CgVec4F32 finalColor = cgLerpVec4F32(topColor, bottomColor, y);

            colorBuffer-&gt;pixels[j * colorBuffer-&gt;width + i] = finalColor;
        }
    }
}

CgVec4F32 cgApplyGammaToVec4F32(CgVec4F32 pixel, float gamma)
{
    CgVec4F32 gammaEncodedPixel = {
        .x = powf(pixel.x, 1.0f / gamma),
        .y = powf(pixel.y, 1.0f / gamma),
        .z = powf(pixel.z, 1.0f / gamma),
        .w = pixel.w
    };
    return gammaEncodedPixel;
}

void cgColorBufferF32ToPPM(const CgColorBufferF32* colorBuffer,
                           const char* path,
                           float gamma)
{
    assert(colorBuffer &amp;&amp; "cgColorBufferF32ToPPM: colorBuffer is NULL");
    assert(path &amp;&amp; "cgColorBufferF32ToPPM: path is NULL");

    FILE* fp = fopen(path, "w");
    if (!fp) {
        perror("cgColorBufferF32ToPPM::fopen:");
        exit(EXIT_FAILURE);
    }
    fprintf(fp, "P3\n");
    fprintf(fp, "%u %u\n", colorBuffer-&gt;width, colorBuffer-&gt;height);
    fprintf(fp, "255\n");
    uint32_t resolution = colorBuffer-&gt;width * colorBuffer-&gt;height;
    for (uint32_t i = 0; i &lt; resolution; ++i) {
        CgVec4F32 pixel = colorBuffer-&gt;pixels[i];
        CgVec4F32 gammaEncodedPixel = cgApplyGammaToVec4F32(pixel, gamma);
        uint8_t red = (uint8_t)(gammaEncodedPixel.x * 255.0f);
        uint8_t green = (uint8_t)(gammaEncodedPixel.y * 255.0f);
        uint8_t blue = (uint8_t)(gammaEncodedPixel.z * 255.0f);
        fprintf(fp, "%u %u %u\n", red, green, blue);
    }
    fclose(fp);
}

int main()
{
    uint32_t width = 320;
    uint32_t height = 240;
    float gamma = 2.2f;
    CgColorBufferF32 colorBuffer = cgCreateColorBufferF32(width, height, cgGetDefaultAllocator());
    CgVec4F32 topLeftColor = { 1.0f, 0.0f, 0.0f, 1.0f };
    CgVec4F32 topRightColor = { 0.0f, 1.0f, 0.0f, 1.0f };
    CgVec4F32 bottomLeftColor = { 0.0f, 0.0f, 1.0f, 1.0f };
    CgVec4F32 bottomRightColor = { 1.0f, 1.0f, 0.0f, 1.0f };
    cgGradientColorBufferF32(&amp;colorBuffer, topLeftColor, topRightColor, bottomLeftColor, bottomRightColor);
    cgColorBufferF32ToPPM(&amp;colorBuffer, "sample.ppm", gamma);
    cgDestroyColorBufferF32(&amp;colorBuffer, cgGetDefaultAllocator());
    return 0;
}
        </code></pre>
    </details>
    </article>
    <h2 id="error-handling">Error Handling</h2>
    <article>
    <p>
        Another issue in need of redressing is the handling of errors. Our code <em>does</em> handle errors (in the sense that at least they aren't ignored) but
        in a very inadequate way. For example,
        when <strong>cgCreateColorBufferF32</strong> fails to allocate memory, it simply outputs a message by calling <strong>perror</strong> and then terminates the application.
        But what if the programmer is interested in <em>logging</em> the message, or maybe she doesn't appreciate the application shutting down and instead would
        rather write her own logic for different failure cases? <strong>cgColorBufferF32ToPPM</strong> has a similar problem&mdash;it
        will shut down the application if it fails to open a file descriptor.
    </p>
    <p>
        We can allow the programmer to provide her own error-handling code, and also provide
        a default error-handling routine as a fallback.
    </p>
    <pre><code class="mono">void cgDefaultErrorCallback(int code, const char* msg)
{
    assert(msg &amp;&amp; "cgDefaultErrorCallback: message is NULL");
    fprintf(stderr, "cgDefaultErrorCallback: %d -&gt; %s\n", code, msg);
    exit(EXIT_FAILURE);
}

typedef void (*CgErrorCallback)(int, const char*);</code></pre>
    <p>
        <strong>cgDefaultErrorCallback</strong> is a bare-bones error-handling routine that exists in case the programmer doesn't provide her own custom error-handling logic.
    </p>
    <p>
        Instead of passing two arguments (one for memory allocation, another for error-handling) we package both in a single structure:
    </p>
    <pre><code class="mono">typedef struct
{
    CgMemoryAllocator* memoryAllocator;
    CgErrorCallback errorCallback;
}
CgApplication;</code></pre>
    <p>
        <strong>cgCreateColorBufferF32</strong> becomes:
    </p>
    <pre><code class="mono">CgColorBufferF32 cgCreateColorBufferF32(CgApplication* application,
                                        uint32_t width,
                                        uint32_t height)
{
    assert(width &gt; 0 &amp;&amp; height &gt; 0 &amp;&amp; "cgCreateColorBufferF32: width or height is zero");
    assert(application &amp;&amp; "cgCreateColorBufferF32: application is NULL");
    assert(application-&gt;memoryAllocator &amp;&amp; "cgCreateColorBufferF32: memoryAllocator is NULL");
    assert(application-&gt;errorCallback &amp;&amp; "cgCreateColorBufferF32: errorCallback is NULL");

    CgColorBufferF32 colorBuffer = {};
    colorBuffer.width = width;
    colorBuffer.height = height;
    colorBuffer.pixels = application-&gt;memoryAllocator-&gt;allocBytes(width * height * sizeof(CgVec4F32));
    if (!colorBuffer.pixels) {
        application-&gt;errorCallback(CG_OUT_OF_MEMORY, "cgCreateColorBufferF32: memory allocation failed");
    }
    return colorBuffer;
}</code></pre>
    <p>
        The programmer essentially initializes a <strong>CgApplication</strong> object in the beginning of the application and passes it to
        functions where it's needed:
    </p>
    <pre><code class="mono">CgApplication application = {
    .memoryAllocator = cgGetDefaultAllocator(),
    .errorCallback = cgDefaultErrorCallback
};</code></pre>
    <details>
        <summary>Click to see the code</summary>
        <pre><code class="mono">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;math.h&gt;

typedef struct
{
    float x;
    float y;
    float z;
    float w;
}
CgVec4F32;

CgVec4F32 cgLerpVec4F32(CgVec4F32 p,
                        CgVec4F32 q,
                        float k)
{
    CgVec4F32 r = {
        .x = (1.0f - k) * p.x + k * q.x,
        .y = (1.0f - k) * p.y + k * q.y,
        .z = (1.0f - k) * p.z + k * q.z,
        .w = (1.0f - k) * p.w + k * q.w
    };
    return r;
}

typedef struct
{
    uint32_t width;
    uint32_t height;
    CgVec4F32* pixels;
}
CgColorBufferF32;

typedef struct
{
    void* (*allocBytes)(size_t);
    void (*freeBytes)(void*);
}
CgMemoryAllocator;

CgMemoryAllocator* cgGetDefaultAllocator()
{
    static CgMemoryAllocator allocator = {
        .allocBytes = malloc,
        .freeBytes = free
    };
    return &allocator;
}

#define CG_SUCCESS          0
#define CG_OUT_OF_MEMORY    1
#define CG_FOPEN_FAILURE    2

void cgDefaultErrorCallback(int code, const char* msg)
{
    assert(code != CG_SUCCESS &amp;&amp; "cgDefaultErrorCallback: CG_SUCCESS cannot be used in error callbacks");
    assert(msg &amp;&amp; "cgDefaultErrorCallback: message is NULL");
    fprintf(stderr, "cgDefaultErrorCallback: %d -&gt; %s\n", code, msg);
}

typedef void (*CgErrorCallback)(int, const char*);

typedef struct
{
    CgMemoryAllocator* memoryAllocator;
    CgErrorCallback errorCallback;
}
CgApplication;

CgColorBufferF32 cgCreateColorBufferF32(CgApplication* application,
                                        uint32_t width,
                                        uint32_t height)
{
    assert(width &gt; 0 &amp;&amp; height &gt; 0 &amp;&amp; "cgCreateColorBufferF32: width or height is zero");
    assert(application &amp;&amp; "cgCreateColorBufferF32: application is NULL");
    assert(application-&gt;memoryAllocator &amp;&amp; "cgCreateColorBufferF32: memoryAllocator is NULL");
    assert(application-&gt;errorCallback &amp;&amp; "cgCreateColorBufferF32: errorCallback is NULL");

    CgColorBufferF32 colorBuffer = {};
    colorBuffer.width = width;
    colorBuffer.height = height;
    colorBuffer.pixels = application-&gt;memoryAllocator-&gt;allocBytes(width * height * sizeof(CgVec4F32));
    if (!colorBuffer.pixels) {
        application-&gt;errorCallback(CG_OUT_OF_MEMORY, "cgCreateColorBufferF32: memory allocation failed");
    }
    return colorBuffer;
}

void cgDestroyColorBufferF32(CgApplication* application,
                             CgColorBufferF32* buffer)
{
    assert(buffer &amp;&amp; "cgDestroyColorBufferF32: buffer is NULL");
    assert(application &amp;&amp; "cgDestroyColorBufferF32: application is NULL");
    assert(application-&gt;memoryAllocator &amp;&amp; "cgDestroyColorBufferF32: memoryAllocator is NULL");

    application-&gt;memoryAllocator-&gt;freeBytes(buffer-&gt;pixels);
    buffer-&gt;width = buffer-&gt;height = 0;
}

void cgGradientColorBufferF32(CgColorBufferF32* colorBuffer,
                              CgVec4F32 topLeftColor,
                              CgVec4F32 topRightColor,
                              CgVec4F32 bottomLeftColor,
                              CgVec4F32 bottomRightColor)
{
    assert(colorBuffer &amp;&amp; "cgGradientColorBufferU32: colorBuffer is NULL");

    for (uint32_t i = 0; i < colorBuffer->width; ++i) {
        float x = (float)i / (float)colorBuffer-&gt;width;
        for (uint32_t j = 0; j < colorBuffer->height; ++j) {
            float y = (float)j / (float)colorBuffer-&gt;height;

            CgVec4F32 topColor = cgLerpVec4F32(topLeftColor, topRightColor, x);
            CgVec4F32 bottomColor = cgLerpVec4F32(bottomLeftColor, bottomRightColor, x);
            CgVec4F32 finalColor = cgLerpVec4F32(topColor, bottomColor, y);

            colorBuffer-&gt;pixels[j * colorBuffer-&gt;width + i] = finalColor;
        }
    }
}

CgVec4F32 cgApplyGammaToVec4F32(CgVec4F32 pixel, float gamma)
{
    assert(gamma != 0.0f &amp;&amp; "cgApplyGammaToVec4F32: gamma cannot be 0");
    CgVec4F32 gammaEncodedPixel = {
        .x = powf(pixel.x, 1.0f / gamma),
        .y = powf(pixel.y, 1.0f / gamma),
        .z = powf(pixel.z, 1.0f / gamma),
        .w = pixel.w
    };
    return gammaEncodedPixel;
}

void cgColorBufferF32ToPPM(CgApplication* application,
                           const CgColorBufferF32* colorBuffer,
                           const char* path,
                           float gamma)
{
    assert(colorBuffer &amp;&amp; "cgColorBufferF32ToPPM: colorBuffer is NULL");
    assert(path &amp;&amp; "cgColorBufferF32ToPPM: path is NULL");
    assert(application &amp;&amp; "cgColorBufferF32ToPPM: application is NULL");
    assert(application-&gt;errorCallback &amp;&amp; "cgColorBufferF32ToPPM: error callback is NULL");

    FILE* fp = fopen(path, "w");
    if (!fp) {
        application-&gt;errorCallback(CG_FOPEN_FAILURE, "cgColorBufferF32ToPPM: couldn't open file");
    }
    fprintf(fp, "P3\n");
    fprintf(fp, "%u %u\n", colorBuffer-&gt;width, colorBuffer-&gt;height);
    fprintf(fp, "255\n");
    uint32_t resolution = colorBuffer-&gt;width * colorBuffer-&gt;height;
    for (uint32_t i = 0; i &lt; resolution; ++i) {
        CgVec4F32 pixel = colorBuffer-&gt;pixels[i];
        CgVec4F32 gammaEncodedPixel = cgApplyGammaToVec4F32(pixel, gamma);
        uint8_t red = (uint8_t)(gammaEncodedPixel.x * 255.0f);
        uint8_t green = (uint8_t)(gammaEncodedPixel.y * 255.0f);
        uint8_t blue = (uint8_t)(gammaEncodedPixel.z * 255.0f);
        fprintf(fp, "%u %u %u\n", red, green, blue);
    }
    fclose(fp);
}

int main()
{
    uint32_t width = 320;
    uint32_t height = 240;
    float gamma = 2.2f;

    CgApplication application = {
        .memoryAllocator = cgGetDefaultAllocator(),
        .errorCallback = cgDefaultErrorCallback
    };

    CgColorBufferF32 colorBuffer = cgCreateColorBufferF32(&amp;application, width, height);
    CgVec4F32 topLeftColor = { 1.0f, 0.0f, 0.0f, 1.0f };
    CgVec4F32 topRightColor = { 0.0f, 1.0f, 0.0f, 1.0f };
    CgVec4F32 bottomLeftColor = { 0.0f, 0.0f, 1.0f, 1.0f };
    CgVec4F32 bottomRightColor = { 1.0f, 1.0f, 0.0f, 1.0f };
    cgGradientColorBufferF32(&amp;colorBuffer, topLeftColor, topRightColor, bottomLeftColor, bottomRightColor);
    cgColorBufferF32ToPPM(&amp;application, &amp;colorBuffer, "sample.ppm", gamma);
    cgDestroyColorBufferF32(&amp;application, &amp;colorBuffer);
    return 0;
}
        </code></pre>
    </details>
    <p>
        We are now ready to begin rendering actual objects, starting from the simplest one.
</p>
    </article>

    <!-- POINTS -->
    <h2 id="points">In the beginning was ... well ... a jot, a speck, a fleck at once incomprehensibly small but unimaginably dense</h2>
    <p class="quote">From Chapter 1 of <a href="https://a.co/d/6zdXWcS" target="_blank">"A Brief History of Earth"</a>, by Andrew H. Knoll.</p>
    <article>
    <p>
        The simplest possible geometry to render is a point.
    </p>
    </article>
</body>
</html>
