<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>The Fall of the House of Vulkan</title>

    <!-- favicon -->
    <link rel="icon" type="image/png" href="../favico/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../favico/favicon.svg" />
    <link rel="shortcut icon" href="../favico/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../favico/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="E954" />
    <link rel="manifest" href="../favico/site.webmanifest" />

    <!-- code highlighting stuff -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/vs.min.css" integrity="sha512-AVoZ71dJLtHRlsgWwujPT1hk2zxtFWsPlpTPCc/1g0WgpbmlzkqlDFduAvnOV4JJWKUquPc1ZyMc5eq4fRnKOQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/arduino-light.min.css" integrity="sha512-M4nH9C7TRCVWLGruh9fHTfYxGWDiKpOGNjpfC9irhF06aLiYmJczZlW+/6IKOZ+75AGk4Wn4clgd6J13T0zzXg==" crossorigin="anonymous" referrerpolicy="no-referrer" /> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/highlight.min.js" integrity="sha512-6yoqbrcLAHDWAdQmiRlHG4+m0g/CT/V9AGyxabG8j7Jk8j3r3K6due7oqpiRMZqcYe9WM2gPcaNNxnl2ux+3tA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/c.min.js" integrity="sha512-Ny9z3+WJkmC2xW098BNYhPajzsf8iBika/+58Mh4lHCF/it92UR32xhytP4I/yxKmF1fkcEgIF87qbGyz1nmDQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>hljs.highlightAll();</script>
    
    <style>
        body {
            max-width: 800px;
            margin: 0 auto;
            font-family: Garamond, serif;
            padding: 50px;
        }

        pre {
            overflow-x: auto;
        }

        a {
            color: darkblue;
        }

        a:hover {
            color: darkgreen;
        }
        
        img {
            width: 800px;
        }

        .mono {
            font-family: 'Courier New', Courier, monospace;
        }

        .inline-code {
            color: white;
            background-color: black;
        }
    </style>

    <!-- Cloudflare Web Analytics -->
    <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "c4b2320f0ee04848bb6f51954d84c0d8"}'></script>
    <!-- End Cloudflare Web Analytics -->
</head>
<body class="max-width-1000 centered black-cat-background">

    <!-- TITLE -->
    <h1 class="title merriweather-black">The Fall of the House of Vulkan</h1>
    <h2 id="prologue" class="chapter merriweather-black">Prologue</h2>

    <!-- INTRODUCTION -->
    <article>
    <p>
        <i>
            During the whole of a dull, dark, and soundless day in the autumn of the year, when the clouds hung oppressively low in the heavens,
            I had been programming alone, on a laptop, a singularly dreary project; and at length found myself, as the shades of the evening
            drew on, within view of the interpolated triangle. I know not how it was, but, with the first glimpse of the API,
            a sense of insufferable doom pervaded my spirit.
        </i>
    </p>
    <p>
        Take a look at this image:
    </p>
    <p>
        <a href="https://en.wikipedia.org/wiki/Utah_teapot#/media/File:Utah_teapot_simple_2.png" target="_blank"><img alt="3D render of the Utah teapot" src="https://upload.wikimedia.org/wikipedia/commons/5/5f/Utah_teapot_simple_2.png"></a>
    </p>
    <p>
        What is it?
    </p>
    <p>
        Well, it's a teapot.
    </p>
    <p>
        Is it <em>real</em>?
    </p>
    <p>
        Of course not.
    </p>
    <p>
        This teapot was <em>inspired</em> by a <a href="https://en.wikipedia.org/wiki/Utah_teapot#/media/File:Original_Utah_Teapot.jpg" target="_blank">real teapot</a>,
        but, alas, the image above is <em>not</em> the image of a real teapot.
        It's an imitation, an artificial reproduction, a simulacrum, and a convincing one at that.
    </p>
    <p>
        Does it matter that it is <em>not</em> real? What is the difference between the real and the fake?
    </p>
    <p>
        I'm not here to discuss <a href="https://a.co/d/5n0AdIY" target="_blank">philosophy</a>.
    </p>
    <p>
        No, I'm here to tell you something more important:
    </p>
    <p class="centered-text big bold">
        You have been scammed.
    </p>
    <p>
        A trillion-dollar industry has convinced you that you need to pay <a href="https://www.amazon.com/s?k=rtx+4090" target="_blank">thousands of dollars</a> to create your own simulacra.
    </p>
    <p>
        And that you also need to write a <a href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/triangle/triangle.cpp" target="_blank">thousand lines</a> of code just to see a single triangle.
    </p>
    <p>
        I am here to tell you that there's another way. That you can do all that by yourself.
    </p>
    <p>
        I know you already think of me as a hero, and I accept this responsibility.
    </p>
    <p class="centered-text big bold italic">
        In your nightmares you use DLSS to upscale your renders, and it brings joy to your heart.
    </p>
    <p>
        So bring up your terminal, open your favorite text editor, and let's make our own simulator.
        You may use an <a href="https://www.learncpp.com/cpp-tutorial/installing-an-integrated-development-environment-ide/" target="_blank">IDE</a> if you wish.
        I am not here to teach you all the technicalities involved
        in compiling and linking the source code, you will have to learn that <a href="https://www.learncpp.com/cpp-tutorial/compiling-your-first-program/" target="_blank">somewhere else</a>.
        Nor will I teach you how to program in <a href="https://a.co/d/8qRAAeX" target="_blank">C</a>.
        But I <em>will</em> teach you the computer science behind generating images like the teapot above.
        No GPUs or <a href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html" target="_blank">convoluted APIs</a> are needed. There is a great joy in writing your own computer graphics code from scratch,
        and my hope is to deliver that joy to <em>you</em>.
    </p>
    </article>

    <!-- FIRST PRINCIPLES -->
    <h2 id="first-principles" class="chapter merriweather-black">First Principles</h2>
    <article>
    <p>
        What is the first step in creating our own <a href="https://en.wikipedia.org/wiki/The_Matrix" target="_blank">matrix</a>?
        We don't just want to build a general-purpose simulation, we want to <em>experience it</em>, too.
        That means we need some sort of a portal into another dimension -
        a <a href="https://narnia.fandom.com/wiki/Wardrobe" target="_blank">wardrobe</a> that opens to Narnia.
        There are different ways of accomplishing this. One of them is by creating an image, and then displaying it on an image viewer.
        But there are <a href="https://en.wikipedia.org/wiki/Image_file_format#Major_graphic_file_formats" target="_blank">so many</a> image formats, which one to choose?
    </p>
    <p>
        One of the simplest image formats is <a href="https://en.wikipedia.org/wiki/Netpbm" target="_blank">PPM</a>.
        Here's an example from wikipedia:
        <table>
            <tr>
                <td>P3</td>
            </tr>
            <tr>
                <td>3</td>
                <td>2</td>
            </tr>
            <tr>
                <td>255</td>
            </tr>
            <tr>
                <td>255</td>
                <td>0</td>
                <td>0</td>
            </tr>
            <tr>
                <td>0</td>
                <td>255</td>
                <td>0</td>
            </tr>
            <tr>
                <td>0</td>
                <td>0</td>
                <td>255</td>
            </tr>
            <tr>
                <td>255</td>
                <td>255</td>
                <td>0</td>
            </tr>
            <tr>
                <td>255</td>
                <td>255</td>
                <td>255</td>
            </tr>
            <tr>
                <td>0</td>
                <td>0</td>
                <td>0</td>
            </tr>
        </table>
    </p>
    <p>
        <strong>P3</strong> denotes that this is an <a href="https://en.wikipedia.org/wiki/ASCII" target="_blank">ASCII</a> file.
        <strong>3</strong> and <strong>2</strong> are the width and the height of the image, respectively.
        <strong>255</strong> on the next line means <em>"end of header"</em>. That is, everything that comes after this line are the actual colors of the image,
        which we discuss next.
    </p>
    <p>
        What <i>is</i> <strong>color</strong>? This may shock you when I say this, but, colors aren't <em>real</em>. They don't actually exist.
        Colors are no more real than the Santa Claus who gifts you presents (or coal!) every Christmas.
        We all partake in a great conspiracy when we open our eyes and see. Colors form an important part of our shared hallucination of the world,
        alongside money and religion. It's funny when you think about it: the teapot that you saw earlier is a lie that approximates another lie
        concocted by the buzzing of neurons inside your <a href="https://en.wikipedia.org/wiki/Visual_cortex" target="_blank">visual cortex</a>.
    </p>
    <p>
        In the real world we have something called <a href="https://en.wikipedia.org/wiki/Electromagnetic_spectrum" target="_blank">the electromagnetic spectrum</a>,
        only a small part of which makes up the wavelengths that the human eye can see:
    </p>
    <p>
        <img alt="Electromagnetic spectrum" src="../img/spectrum.svg">
    </p>
    <p>
        Worse, the cells within your eye have different sensitivities to different parts of the visible spectrum.
        The image below (which I yoinked from <a href="https://www.simplypsychology.org/what-is-the-trichromatic-theory-of-color-vision.html" target="_blank">simplepsychology.org</a>)
        illustrates this nicely: 
    </p>
    <p>
        <img alt="Human color sensitivities" src="../img/eye-color-sensitivity.webp">
    </p>
    <p>
        I inverted the colors so that it doesn't burn your eyes. Here's the <a href="https://www.simplypsychology.org/wp-content/uploads/eye-color-sensitivity.png" target="_blank">real image</a>.
        The point is that you may see some colors <em>"brighter"</em> than others.
        Also, due to the awkward wiring of the optical nerve, you have been gifted a blind spot:
    </p>
    <p>
        <img alt="Human eye blind spot" src="../img/blind-spot.jpg">
    </p>
    <p>
        <i>"But... I don't see any dark patches in my vision?!"</i>, you might say.
        Well, thanks to this oopsie made by the clunky hand of evolution,
        your brain now has to compensate for this by literally <a href="https://en.wikipedia.org/wiki/Blind_spot_(vision)" target="_blank">filling in</a> the void.
        Life decided that it would rather hallucinate than to actually see.
    </p>
    <p class="centered-text big bold italic">
        You are already in the <a href="https://en.wikipedia.org/wiki/Metaverse" target="_blank">Metaverse</a>,
        and you have never really touched grass.
    </p>
    <p>
        By the way, cephalopods <a href="https://youtu.be/HATW8xJMxAc?si=E_YykDNmXw-hIPkN" target="_blank">don't have this problem</a>.
    </p>
    <p>
        What I want you to get from all this is that everything that you see is fake: you are fake, I am fake, your Mom is fake...
    </p>
    <p>
        As long as our delusions don't harm the reproductive success of our species, they will persist,
        and we seem to be the only species to use technology to indulge ourselves in artificial delusions.
        We went from <a href="https://en.wikipedia.org/wiki/Lascaux" target="_blank">cave paintings</a> to <a href="https://youtu.be/dYk7byKHSRw?feature=shared" target="_blank">this</a>
        in the blink of an eye (in cosmological timescales).
        There is clearly great value in running simulations, especially those that we get to <em>experience</em>.
        There are philosophers who think the simulation is <a href="https://simulation-argument.com/" target="_blank">the final technology</a>.
    </p>
    <p>
        That being said, the chicanery of light and color is often too complex for computers to handle
        (especially when we want to generate our images <em>fast</em>).
        Instead what we do is take the visible part of the electromagnetic spectrum and quantize it based on the intensity of three colors:
        <span style="color: red;">RED</span>, <span style="color: green;">GREEN</span>, and <span style="color: blue;">BLUE</span>,
        to the much chagrin of <a href="https://en.wikipedia.org/wiki/Tetrachromacy" target="_blank">tetrachromats</a>.
        We represent each of these intensities as an 8-bit unsigned integer between 0 and 255.
        This gives us a total of 256 * 256 * 256 = 16777216 (~16 million) colors to work with. Not bad.
    </p>
    <p>
        Take a look at that PPM image again. The first row is:
    </p>
    <p>
        <table>
            <tr>
                <td>255</td>
                <td>0</td>
                <td>0</td>
            </tr>
        </table>
    </p>
    <p>
        This array of numbers represents the <span style="color: red;">RED</span> color.
        The next row is:
    </p>
    <p>
        <table>
            <tr>
                <td>0</td>
                <td>255</td>
                <td>0</td>
            </tr>
        </table>
    </p>
    <p>
        This is the <span style="color: green;">GREEN</span> color.
        When we <em>interpret</em> the color information together with the width and the height of the image, we get the following picture:
    </p>
    <p>
        <img alt="PPM image example" src="../img/ppm.svg">
    </p>
    <p>
        We now know that to generate images we will need a structure that stores width, height, and an array of numbers that represents the colors.
        So, let us do that:
    </p>
    <pre><code class="mono">#include &ltstdio.h&gt
#include &ltstdint.h&gt
#include &ltstdlib.h&gt
#include &ltassert.h&gt

typedef struct
{
    uint8_t x;
    uint8_t y;
    uint8_t z;
    uint8_t w;
}
CgVec4U8;

typedef struct
{
    uint32_t width;
    uint32_t height;
    uint32_t* pixels;
}
CgColorBufferU32;

CgColorBufferU32 cgCreateColorBufferU32(uint32_t width,
                                        uint32_t height)
{
    assert(width &gt 0 && height &gt 0 && "cgCreateColorBufferU32: width or height is zero");

    CgColorBufferU32 colorBuffer = {};
    colorBuffer.width = width;
    colorBuffer.height = height;
    colorBuffer.pixels = malloc(width * height * sizeof(uint32_t));
    if (!colorBuffer.pixels) {
        perror("cgCreateColorBufferU32");
        exit(EXIT_FAILURE);
    }
    return colorBuffer;
}

void cgClearColorBufferU32(CgColorBufferU32* restrict colorBuffer,
                           CgVec4U8 color)
{
    assert(colorBuffer && "cgClearColorBufferU32: colorBuffer is NULL");

    uint32_t pixel = ((uint32_t)color.x) |
                     ((uint32_t)color.y &lt&lt 8) |
                     ((uint32_t)color.z &lt&lt 16) |
                     ((uint32_t)color.w &lt&lt 24);

    uint32_t resolution = colorBuffer-&gtwidth * colorBuffer-&gtheight;
    for (uint32_t i = 0; i &lt resolution; ++i) {
        colorBuffer-&gtpixels[i] = pixel;
    }
}

void cgColorBufferU32ToPPM(const CgColorBufferU32* restrict colorBuffer,
                           const char* restrict path)
{
    assert(colorBuffer && "cgColorBufferU32ToPPM: colorBuffer is NULL");
    assert(path && "cgColorBufferU32ToPPM: path is NULL");

    FILE* fp = fopen(path, "w");
    if (!fp) {
        perror("cgColorBufferU32ToPPM");
        exit(EXIT_FAILURE);
    }
    fprintf(fp, "P3\n");
    fprintf(fp, "%u %u\n", colorBuffer-&gtwidth, colorBuffer-&gtheight);
    fprintf(fp, "255\n");
    uint32_t resolution = colorBuffer-&gtwidth * colorBuffer-&gtheight;
    for (uint32_t i = 0; i &lt resolution; ++i) {
        uint32_t pixel = colorBuffer-&gtpixels[i];
        uint8_t red = *((uint8_t*)&pixel + 0);
        uint8_t green = *((uint8_t*)&pixel + 1);
        uint8_t blue = *((uint8_t*)&pixel + 2);
        fprintf(fp, "%u %u %u\n", red, green, blue);
    }
    fclose(fp);
}

int main()
{
    uint32_t width = 320;
    uint32_t height = 240;
    CgVec4U8 clearColor = { 255, 150, 255, 255 };
    CgColorBufferU32 colorBuffer = cgCreateColorBufferU32(width, height);
    cgClearColorBufferU32(&colorBuffer, clearColor);
    cgColorBufferU32ToPPM(&colorBuffer, "sample.ppm");
    return 0;
}</code></pre>
    <p>
        Running the code above creates the image below:
    </p>
    <p>
        <img alt="Output of the code" src="../img/cursedgl_0.png">
    </p>
    <p>
        I converted the PPM to <a href="https://en.wikipedia.org/wiki/PNG" target="_blank">PNG</a> since web browsers can't render PPM images
        (maybe some can, but <a href="https://www.mozilla.org/en-US/firefox/" target="_blank">firefox</a> couldn't).
    </p>
    <p>
        There is a long way to go before our image starts to look like a teapot. But we already have the fundamental structures:
    </p>
    <pre><code class="mono">typedef struct
{
    uint8_t x;
    uint8_t y;
    uint8_t z;
    uint8_t w;
}
CgVec4U8;</code></pre>
    <p>
        Since C doesn't have namespaces, I name my structures with a two-letter identifier <span class="inline-code">Cg</span> to prevent naming conflicts.
        Here, <span class="inline-code">Cg</span> stands for "Computer graphics", but you may use your own naming scheme if you wish.
        Next, <span class="inline-code">Vec4</span> stands for the 4-dimensional vector
        (if you need some refreshing on vectors, <a href="https://www.realtimerendering.com/" target="_blank">realtimerendering.com</a>
        has a nice <a href="https://www.realtimerendering.com/Real-Time_Rendering_4th-Appendices.pdf" target="_blank">PDF</a> that you can read).
        Finally, I indicate the type of the elements in the structure: <span class="inline-code">U8</span>, which stands for 8-bit unsigned integer.
    </p>
    <p>
        Therefore, a 4D floating-point vector can be defined as <span class="inline-code">CgVec4F32</span>:
    </p>
    <pre><code class="mono">typedef struct
{
    float x;
    float y;
    float z;
    float w;
}
CgVec4F32;</code></pre>
    <p>
        The struct <span class="inline-code">CgColorBufferU32</span> follows the same convention.
        After all, we need a place to <em>store</em> the image, so we will use the <span class="inline-code">pixels</span> pointer
        to refer to some place in memory where the image is stored:
    </p>
    <pre><code class="mono">typedef struct
{
    uint32_t width;
    uint32_t height;
    uint32_t* pixels;
}
CgColorBufferU32;</code></pre>
    <p>
        Each pixel is defined as an unsigned 32-bit integer (8-bit per channel, with an alpha value that we will discuss later).
    </p>
    <p>
        Then we define the <span class="inline-code">cgCreateColorBufferU32</span> function that allocates a new buffer to store the image.
        Note that the <span class="inline-code">cgCreateColorBufferU32</span> doesn't <em>initialize</em> the buffer,
        it only <em>allocates</em> enough memory to <em>store</em> the image.
        This goes against the <strong>"never forget initializing your variables"</strong> mantra, but
        the values of the color buffer are likely to be discarded and written to anyway,
        so it doesn't really make sense to initialize it with default color values.
        Instead we have another function that updates the color buffer given a single color:
        <span class="inline-code">cgClearColorBufferU32</span>. Note how the 32-bit pixels are generated:
    </p>
    <pre><code class="mono">uint32_t pixel = ((uint32_t)color.x) |
                 ((uint32_t)color.y &lt&lt 8) |
                 ((uint32_t)color.z &lt&lt 16) |
                 ((uint32_t)color.w &lt&lt 24);</code></pre>
    <p>
        Here the <strong>x</strong>, <strong>y</strong>, <strong>z</strong>, <strong>w</strong>
        values correspond to the <span style="color: red;">red</span>, <span style="color: green;">green</span>,
        <span style="color: blue;">blue</span>, and <span>alpha</span> values.
        What is <em>alpha</em>? Roughly speaking, the alpha represents the transparency of the image.
        That is to say, if there was <em>another</em> image behind <em>our</em> image, then the alpha values
        of our image would determine <em>the extent to which</em> the colors of the background image would <em>bleed through</em> our image.
        This description is a little abstract, but don't worry, we will look at transparency in more detail later.
    </p>
    <p>
        Each <span class="inline-code">uint32_t pixel</span> stores the red value in its least significant 8 bits
        (assuming that we are programming in a <a href="https://en.wikipedia.org/wiki/Endianness" target="_blank">little-endian</a> machine).
        Why? For no particular reason. Different applications may use different pixel layouts, and switching between layouts is trivial.
        But once the layout is determined, we have to be consistent, and we are: our function <span class="inline-code">cgColorBufferU32ToPPM</span>
        assumes the red will be found in the least significant 8 bits of the given <span class="inline-code">uint32_t</span> value:
    </p>
    <pre><code class="mono">uint32_t pixel = colorBuffer-&gtpixels[i];
uint8_t red = *((uint8_t*)&pixel + 0);
uint8_t green = *((uint8_t*)&pixel + 1);
uint8_t blue = *((uint8_t*)&pixel + 2);
fprintf(fp, "%u %u %u\n", red, green, blue);</code></pre>
    <p>
        An image with a single color is kind of boring though. We can write another function <span class="inline-code">cgGradientColorBufferU32</span>
        that draws a gradient across the image:
    </p>
    <pre><code class="mono">void cgGradientColorBufferU32(CgColorBufferU32* restrict colorBuffer,
                              CgVec4U8 topLeftColor,
                              CgVec4U8 topRightColor,
                              CgVec4U8 bottomLeftColor,
                              CgVec4U8 bottomRightColor)
{
    assert(colorBuffer && "cgGradientColorBufferU32: colorBuffer is NULL");

    CgVec4F32 topLeftColorF32 = cgConvertVec4U8ToF32(topLeftColor);
    CgVec4F32 topRightColorF32 = cgConvertVec4U8ToF32(topRightColor);
    CgVec4F32 bottomLeftColorF32 = cgConvertVec4U8ToF32(bottomLeftColor);
    CgVec4F32 bottomRightColorF32 = cgConvertVec4U8ToF32(bottomRightColor);

    for (uint32_t i = 0; i &lt colorBuffer->width; ++i) {
        float x = (float)i / (float)colorBuffer->width;
        for (uint32_t j = 0; j &lt colorBuffer->height; ++j) {
            float y = (float)j / (float)colorBuffer->height;

            CgVec4F32 topColor = cgLerpVec4F32(topLeftColorF32, topRightColorF32, x);
            CgVec4F32 bottomColor = cgLerpVec4F32(bottomLeftColorF32, bottomRightColorF32, x);
            CgVec4F32 finalColor = cgLerpVec4F32(topColor, bottomColor, y);

            CgVec4U8 color = cgConvertVec4F32ToU8(finalColor);
            uint32_t pixel = cgConvertVec4U8ToU32(color);
            colorBuffer->pixels[j * colorBuffer->width + i] = pixel;
        }
    }
}</code></pre>
    <p>
        We can create gradients by <em>linearly interpolating</em> between the given color values.
        To understand linear interpolation better let us interpolate between two real values, say <span class="inline-code">a</span>
        and <span class="inline-code">b</span>. We can define <span class="inline-code">k</span> as another real value,
        between 0.0 and 1.0, that denotes the <em>amount</em> of interpolation to do.
        You can think of <span class="inline-code">k</span> as the <em>distance</em> to travel from
        <span class="inline-code">a</span> to <span class="inline-code">b</span>.
        When <span class="inline-code">k</span> equals 0, we don't travel at all, so we return <span class="inline-code">a</span>.
        When <span class="inline-code">k</span> equals 1, then we travel the full distance, and thus we return <span class="inline-code">b</span>.
        If <span class="inline-code">k</span> equals 0.5, then we travel half the distance, so return the half of <span class="inline-code">a</span>
        plus the half of <span class="inline-code">b</span>.
    </p>
    <p>
        In our case we are trying to interpolate across a two-dimensional surface (our image), so we have two <span class="inline-code">k</span>s.
        We can calculate these <span class="inline-code">k</span>s by dividing the position of the current pixel
        (<span class="inline-code">i</span> and <span class="inline-code">j</span>) by the width and the height of our image.
        This works because <span class="inline-code">i</span> will always be between 0 and the width of the image,
        so dividing <span class="inline-code">i</span> by the width will always yield a value between 0.0 and 1.0
        (technically speaking, we will never reach 1.0, since <span class="inline-code">i</span> will never be the width of the image, but this is okay, because it will get
        very close to 1.0 anyway. If you're bothered by this, you can instead divide by (width - 1), which <em>will</em> produce the correct interpolation).
        The same remark applies to <span class="inline-code">j</span>: diving <span class="inline-code">j</span> by the height of the image will also produce a value between 0.0 and 1.0.
    </p>
    <p>
        Now we can use these <span class="inline-code">k</span>s to linearly interpolate between the given color values.
        Because <span class="inline-code">k</span>s are floating-point values, it's best that we convert our colors to their
        floating-point equivalents as well, lest we litter the codebase with <a href="https://stackoverflow.com/questions/7558837/what-exactly-is-a-type-cast-in-c-c" target="_blank">type casts</a>.
        Instead we hide the casts in functions, e.g. with <span class="inline-code">cgConvertVec4U8ToF32</span>:
    </p>
    <pre><code class="mono">CgVec4F32 cgConvertVec4U8ToF32(CgVec4U8 v)
{
    CgVec4F32 r = { .x = (float)v.x,
                    .y = (float)v.y,
                    .z = (float)v.z,
                    .w = (float)v.w };
    return r;
}</code></pre>
    <p>
        The linear interpolation is computed by the <span class="inline-code">cgLerpVec4F32</span> function:
    </p>
    <pre><code class="mono">CgVec4F32 cgLerpVec4F32(CgVec4F32 p,
                        CgVec4F32 q,
                        float k)
{
    CgVec4F32 r = {
        .x = (1.0f - k) * p.x + k * q.x,
        .y = (1.0f - k) * p.y + k * q.y,
        .z = (1.0f - k) * p.z + k * q.z,
        .w = (1.0f - k) * p.w + k * q.w
    };
    return r;
}</code></pre>
    <p>
        Notice how when <span class="inline-code">k</span> equals 0, we return the first value (<span class="inline-code">p</span>),
        and when it equals 1, we return the second value (<span class="inline-code">q</span>), and for the remaining values of
        <span class="inline-code">k</span> it is a mixture of both.
        Once interpolated, we convert the <span class="inline-code">CgVec4F32</span> back to <span class="inline-code">CgVec4U8</span>
        using <span class="inline-code">cgConvertVec4F32ToU8</span>:
    </p>
    <pre><code class="mono">CgVec4U8 cgConvertVec4F32ToU8(CgVec4F32 v)
{
    CgVec4U8 r = { .x = (uint8_t)v.x,
                   .y = (uint8_t)v.y,
                   .z = (uint8_t)v.z,
                   .w = (uint8_t)v.w };
    return r;
}</code></pre>
    <p>
        But since we store pixels as <span class="inline-code">uint32_t</span> values, we need to convert our <span class="inline-code">CgVec4U8</span>
        to a 32-bit unsigned integer via <span class="inline-code">cgConvertVec4U8ToU32</span>:
    </p>
    <pre><code class="mono">uint32_t cgConvertVec4U8ToU32(CgVec4U8 color)
{
    uint32_t pixel = ((uint32_t)color.x) |
                     ((uint32_t)color.y &lt&lt 8) |
                     ((uint32_t)color.z &lt&lt 16) |
                     ((uint32_t)color.w &lt&lt 24);
    return pixel;
}</code></pre>
    <p>
        If we use <span style="color: red;">RED</span> for the top-left color,
        <span style="color: green;">GREEN</span> for the top-right color,
        <span style="color: blue;">BLUE</span> for the bottom-left color, and
        <span style="color: yellow;">YELLOW</span> for the bottom-right color, then <span class="inline-code">cgGradientColorBufferU32</span> will produce the following image:
    </p>
    <p>
        <img alt="Output of the code" src="../img/cursedgl_1.png">
    </p>
    <p>
        You need to understand interpolation <em>well</em>, because we will use it again, albeit for a different geometry.
    </p>
    </article>

    <!-- FLOATING-POINT BUFFERS -->
    <h2 id="floating-point-buffers" class="chapter merriweather-black">Floating-point Buffers</h2>
    <article>
    <p>
        So far we have been storing our color values in <span class="inline-code">CgColorBufferU32</span>,
        and while there isn't anything inherently wrong with 8-bit colors, it is often much easier to work
        with floating-point values. We have already seen this in the <span class="inline-code">cgGradientColorBufferU32</span>
        function. Linear interpolation works best with floating-point values as the <em>amount to interpolate</em> between two values
        is best given by a real number between 0.0 and 1.0. In our case we could have simply defined a <span class="inline-code">uint8_t</span>
        variant of the 
    </p>
    </article>
</body>
</html>
